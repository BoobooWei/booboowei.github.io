<!DOCTYPE html>
<html lang="en">
<head prefix="og: http://ogp.me/ns#">
  <meta charset="utf-8">
  <title>MySQL 逻辑架构 和 Innodb 存储引擎 | BoobooWei</title>
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- Canonical links -->
  <link rel="canonical" href="http://www.toberoot.com/database/mysql/booboo_mysql/03-MySQL%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84%E5%92%8CInnodb%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E">
  <!-- Alternate links -->
  
    
      
    
    <link rel="alternate" hreflang="x-default" href="http://www.toberoot.com/database/mysql/booboo_mysql/03-MySQL%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84%E5%92%8CInnodb%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E" />
  
  <!-- Icon -->
  <link rel="apple-touch-icon" sizes="57x57" href="../../../icon/apple-touch-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="114x114" href="../../../icon/apple-touch-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="72x72" href="../../../icon/apple-touch-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="144x144" href="../../../icon/apple-touch-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="60x60" href="../../../icon/apple-touch-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="120x120" href="../../../icon/apple-touch-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="76x76" href="../../../icon/apple-touch-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="152x152" href="../../../icon/apple-touch-icon-152x152.png">
  <link rel="icon" type="image/png" href="../../../icon/favicon-196x196.png" sizes="196x196">
  <link rel="icon" type="image/png" href="../../../icon/favicon-160x160.png" sizes="160x160">
  <link rel="icon" type="image/png" href="../../../icon/favicon-96x96.png" sizes="96x96">
  <link rel="icon" type="image/png" href="../../../icon/favicon-16x16.png" sizes="16x16">
  <link rel="icon" type="image/png" href="../../../icon/favicon-32x32.png" sizes="32x32">
  <meta name="msapplication-TileColor" content="#2f83cd">
  <meta name="msapplication-TileImage" content="../../../icon/mstile-144x144.png">
  <!-- CSS -->
  <!-- build:css build/css/navy.css -->
  
<link rel="stylesheet" href="../../../css/navy.css">

  <!-- endbuild -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-lato@0.0.75/index.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.3.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css">
  <!-- RSS -->
  <link rel="alternate" href="../../../atom.xml" title="BoobooWei" type="application/atom+xml">
  <!-- Open Graph -->
  <meta name="description" content="MySQL 逻辑架构 MySQL 逻辑架构由：连接池组件、管理服务和工具组件、sql接口组件、查询分析器组件、优化器组件、 缓冲组件、插件式存储引擎、物理文件组成。独有的插件式体系结构，各个存储引擎有自己的特点。  Connectors指的是不同语言中与SQL的交互  Management Serveices &amp; Utilities： 系统管理和控制工具  Connection Pool:">
<meta property="og:type" content="website">
<meta property="og:title" content="MySQL 逻辑架构 和 Innodb 存储引擎">
<meta property="og:url" content="http://www.toberoot.com/database/mysql/booboo_mysql/03-MySQL%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84%E5%92%8CInnodb%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E">
<meta property="og:site_name" content="BoobooWei">
<meta property="og:description" content="MySQL 逻辑架构 MySQL 逻辑架构由：连接池组件、管理服务和工具组件、sql接口组件、查询分析器组件、优化器组件、 缓冲组件、插件式存储引擎、物理文件组成。独有的插件式体系结构，各个存储引擎有自己的特点。  Connectors指的是不同语言中与SQL的交互  Management Serveices &amp; Utilities： 系统管理和控制工具  Connection Pool:">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://www.toberoot.com/icon/og-image-wide.png">
<meta property="article:published_time" content="2025-10-22T08:53:55.852Z">
<meta property="article:modified_time" content="2025-10-22T08:48:27.534Z">
<meta property="article:author" content="魏亚萍">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://www.toberoot.com/icon/twitter-summary.png">
<meta property="fb:admins" content="100000247608790">
  <!-- Google Analytics -->
  
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-48498357-3', 'auto');
  ga('send', 'pageview');
</script>

  <!-- Algolia -->
  <link rel="preconnect" href="https://-dsn.algolia.net" crossorigin />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@docsearch/css@3">
<meta name="generator" content="Hexo 8.0.0"></head>

<body>
  <div id="container">
    <header id="header" class="wrapper">
  <div id="header-inner" class="inner">
    <h1 id="logo-wrap">
      <a href="../../../" id="logo">Hexo</a>
    </h1>
    <nav id="main-nav">
      <a href="../../../docs/" class="main-nav-link">Hexo</a><a href="../../../news/" class="main-nav-link">News</a><a href="../../../api/" class="main-nav-link">MySQL8.0</a><a href="../../../database/" class="main-nav-link">Database</a><a href="../../../linux/" class="main-nav-link">Linux</a><a href="../../../cloud/" class="main-nav-link">Cloud</a><a href="../../../singapore/" class="main-nav-link">Singapore</a><a href="../../../amy/" class="main-nav-link">AMY</a><a href="../../../about/" class="main-nav-link">About</a>
      <a target="_blank" rel="noopener" href="https://github.com/BoobooWei" class="main-nav-link"><i class="fa fa-github-alt"></i></a>

      <div id="search-input-wrap">
        <div id="search-input-icon">
          <i class="fa fa-search"></i>
        </div>
        <input type="search" id="search-input" placeholder="Search...">
      </div>
    </nav>
    <div id="lang-select-wrap">
        <a href="/about/" class="main-nav-link"><label id="lang-select-label"><i class="fa fa-globe"></i><span>关于我</span></label></a>
    </div>
    <a id="mobile-nav-toggle">
      <span class="mobile-nav-toggle-bar"></span>
      <span class="mobile-nav-toggle-bar"></span>
      <span class="mobile-nav-toggle-bar"></span>
    </a>
  </div>
</header>

    <div id="content-wrap">
  <div id="content" class="wrapper">
    <div id="content-inner">
      <article class="article-container" itemscope itemtype="http://schema.org/Article">
        <div class="article-inner">
          <div class="article">
            <div class="inner">
              <header class="article-header">
                <h1 class="article-title" itemprop="name">MySQL 逻辑架构 和 Innodb 存储引擎</h1>
                <a target="_blank" rel="noopener" href="https://github.com/BoobooWei/site/edit/master/source/database/mysql/booboo_mysql/03-MySQL逻辑架构和Innodb存储引擎.md" class="article-edit-link" title="Improve this doc"><i class="fa fa-pencil"></i></a>
              </header>
              <div class="article-content" itemprop="articleBody">
                <html><head></head><body><h1 id="MySQL-逻辑架构" class="article-heading"><a href="#MySQL-逻辑架构" class="headerlink" title="MySQL 逻辑架构"></a>MySQL 逻辑架构<a class="article-anchor" href="#MySQL-逻辑架构" aria-hidden="true"></a></h1><p><img src="pic/04-mysql2.jpg" alt="逻辑架构"></p>
<p>MySQL 逻辑架构由：连接池组件、管理服务和工具组件、sql接口组件、查询分析器组件、优化器组件、 缓冲组件、插件式存储引擎、物理文件组成。独有的插件式体系结构，各个存储引擎有自己的特点。</p>
<ul>
<li><p><code>Connectors</code>指的是不同语言中与SQL的交互</p>
</li>
<li><p><code>Management Serveices &amp; Utilities</code>： 系统管理和控制工具</p>
</li>
<li><p><code>Connection Pool</code>: 连接池。管理缓冲用户连接，线程处理等需要缓存的需求</p>
</li>
<li><p><code>SQL Interface</code>: SQL接口。接受用户的SQL命令，并且返回用户需要查询的结果。比如<code>select from</code>就是调用S<code>QL Interface</code></p>
</li>
<li><p><code>Parser</code>: 解析器。SQL命令传递到解析器的时候会被解析器验证和解析。解析器是由Lex和YACC实现的，是一个很长的脚本。</p>
<p>主要功能：</p>
<p>a . 将SQL语句分解成数据结构，并将这个结构传递到后续步骤，以后SQL语句的传递和处理就是基于这个结构的</p>
<p>b. 如果在分解构成中遇到错误，那么就说明这个sql语句是不合理的</p>
</li>
<li><p><code>Optimizer</code>: 查询优化器。SQL语句在查询之前会使用查询优化器对查询进行优化。他使用的是”选取-投影-联接”策略进行查询。</p>
<p>用一个例子就可以理解： <code>select uid,name from user where gender = 1;</code></p>
<p>这个<code>select</code> 查询先根据<code>where</code> 语句进行选取，而不是先将表全部查询出来以后再进行<code>gender</code>过滤；这个<code>select</code>查询先根据<code>uid</code>和<code>name</code>进行属性投影，而不是将属性全部取出以后再进行过滤；将这两个查询条件联接起来生成最终查询结果</p>
</li>
<li><p><code>Cache</code>和<code>Buffer</code>： 查询缓存。</p>
<p>如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等</p>
</li>
<li><p><code>Engine</code> ：存储引擎。</p>
<p>存储引擎是MySql中具体的与文件打交道的子系统。也是Mysql最具有特色的一个地方。</p>
<p>Mysql的存储引擎是插件式的。它根据MySQL AB公司提供的文件访问层的一个抽象接口来定制一种文件访问机制（这种访问机制就叫存储引擎）</p>
<p>现在有很多种存储引擎，各个存储引擎的优势各不一样，最常用的MyISAM,InnoDB</p>
<p>MySQL 5.5 版本之前默认使用MyISAM引擎，它查询速度快，有较好的索引优化和数据压缩技术。但是它不支持事务。</p>
<p>MySQL 5.5 版本开始默认使用InnoDB引擎，它是第一个支持拥有ACID特性事务的存储引擎，并且提供行级的锁定，应用也相当广泛。</p>
<p>Mysql也支持自己定制存储引擎，甚至一个库中不同的表使用不同的存储引擎，这些都是允许的。</p>
</li>
</ul>
<h1 id="MySQL-存储引擎" class="article-heading"><a href="#MySQL-存储引擎" class="headerlink" title="MySQL 存储引擎"></a>MySQL 存储引擎<a class="article-anchor" href="#MySQL-存储引擎" aria-hidden="true"></a></h1><h2 id="存储引擎概述" class="article-heading"><a href="#存储引擎概述" class="headerlink" title="存储引擎概述"></a>存储引擎概述<a class="article-anchor" href="#存储引擎概述" aria-hidden="true"></a></h2><p><code>innodb</code>存储引擎：面向OLTP(online transaction processing)、行锁、支持外键、非锁定读、默认采用repeaable级别（可重复读）通过next-keylocking策略避免幻读、插入缓冲、二次写、自适应哈希索引、预读</p>
<p><code>myisam</code>存储引擎：不支持事务、表锁、全文索引、适合olap（在线分析处理），其中myd:放数据文件，myi:放索引文件</p>
<p><code>ndb</code>存储引擎：集群存储引擎，share nothing，可提高可用性</p>
<p><code>memory</code>存储引擎：数据存放在内存中，表锁，并发性能差，默认使用哈希索引</p>
<p><code>archive</code>存储引擎：只支持<code>insert</code>和<code>select</code> ，zlib算法压缩1：10，适合存储归档数据如日志等、行锁</p>
<p><code>maria</code>存储引擎：目的取代myisam、缓存数据和索引、行锁、mvcc</p>
<p><img src="pic/14-engine.jpg" alt="engine diff"></p>
<hr>
<h2 id="知名的两大存储引擎" class="article-heading"><a href="#知名的两大存储引擎" class="headerlink" title="知名的两大存储引擎"></a>知名的两大存储引擎<a class="article-anchor" href="#知名的两大存储引擎" aria-hidden="true"></a></h2><p>存储引擎是数据库当中非常重要的概念，这是一个重点。什么是存储引擎呢？引擎这个东西是用在车上的，说车子跑快跑慢，最直接的关系，引擎，当然不是唯一的关系。就像我们说计算机cpu是最直接的原因。对汽车来说呢，就是引擎最关键。数据库他的优点是数据读写比较快，那么他读写之所以比一般的应用程序快，那是因为他读写的方式不一样。我们把数据库读数据，读文件，写数据，写文件，那种读写操作的方法叫做存储引擎。指的是”DB读写数据的方式”。简单的一句话概括，数据库读写数据的方式叫做存储引擎。读写数据的方式会直接影响到数据库性能，所以是非常重要的。mysql用的是两大存储引擎，一个叫做myisam存储引擎，第二个叫做innodb存储引擎，这是最常见的、最知名的存储引擎，myisam和innodb存储引擎。其实还有其他存储引擎，大概我记得mysql支持8个不同的存储引擎，可能后来呢又扩容了，但是不管有几个，最常用的就是这么两个。</p>
<p>这两个存储引擎有各自的优劣点，有各自的特性。比如说，两个最大的区别，myisam是一个非事务型的存储引擎，可以支持表锁，或者说只支持表锁；innodb是一个事务型存储引擎，能够支持到行锁。这是两个特性，不是说事务型存储就能支持行锁，这是两个不同的特点，一个特点是事务型和非事务型，一个特点是行锁与表锁。实现行锁，其实大部分引擎实现的都是表锁，实现表锁的存储引擎不多，innodb是其中一个，ndb也是一个，比较著名的能够实现行锁的存储引擎。</p>
<p>INNODB可以实现行锁，所以INNODB在线上生存环境中，大并发用户请求下，他的性能损失并不大；而MYISAM用的是表锁，一旦并发用户数量多了，性能会急剧下降，随着他们用户数量的增加，冲突会明显增加，冲突次数越多，性能越低，排队用户越多。我们这里总结一下，我们推荐线上生产环境尽量使用INNODB，会有很多优点；但如果不涉及到锁冲突，不涉及到事务型，或者说不涉及到写操作，比如我这台服务器专门用来读，那么这个时候MYISAM的读性能是大于INNODB的，他是适合于小并发下面的读多写少的环境。锁行比锁表要麻烦，锁精度越精细，操作起来肯定越麻烦，所以在只读的环境下，用MYISAM肯定性能会高一些。多数情况下MYISAM存储引擎呢是给管理员做统计用的。管理员有一个数据库要去分析数据，一个人分析就够了，不会说有一千个用户同时登上去，大家一起分析，不会的。而且分析数据库，很多都是用的读环境，这个表当中有多少记录，哪个表当中有多少记录，表当中最大值是多少，最小值是多少，相对于上一次的统计结果我有什么样的改变，很多时候都是读操作。所以像这种线下数据统计分析比较适合于MYISAM。 另外提一下，还有一种情况下也会用MYISAM。在做主从同步的时候，也称为A/B复制。有一台服务器叫做Master，有一堆从服务器叫做Slave，Master用来做写操作，写完以后同步给从机，从机只用来做读操作。那么从机就是一个只读环境，用MYISAM数据库引擎，是不是符合我们读多写少的环境啊，而主服务器用INNODB，这也是一种架构的方式，了解一下，有的公司比较追求读性能就会用这种架构，但是我们大多数时候是主从都用INNODB。</p>
<p>接下来我们一起来了解一下MYSQL和MARIADB默认的存储引擎是什么，就是说你什么操作都不改，做数据读写的时候默认使用的存储引擎。MYSQL有几个不同的版本，在SUN公司手下的时候，有5.0版本和5.1版本，默认使用MYISAM存储引擎；后来被ORACLE收购之后的第一版本是5.5，开发的第二个版本是5.6，现在最新的版本是5.7，ORACLE收购完默认的存储引擎是INNODB。MARIADB有5.0，5.1相对于MYSQL的5.0和5.1，有一个MYSQL版本，就会有一个MARIADB版本。RHEL7默认用的MARIADB 5.5版本，MYSQL有5.6版本，MARIADB对应的是10版本，MYSQL 5.7版本，对应的是MARIADB 10.1版本。MARIADB说我以后不会跟着你的版本走，因为我后期开发的过程中，功能比你多，所以我版本跟你一样，会让用户有一个错误的判断，认为好像我有的功能MYSQL也有，而事实上MYSQL没有，我是超越MYSQL的。 ORACLE官方说，MYSQL 5.6版本性能要高出5.5版本的30%，相同的硬件，相同的机器上面，性能要高出30%。5.7相对于5.6高70%，这东西一般来说，我们在性能调优的时候是很难想象的，在相同的硬件上面，因为程序稍作修改让性能提升这么大。一般来说程序版本升级之后，性能增加个5%-10%，这是在一个可以理解的，通常的方案当中，但是ORACLE说能提升70%，他的确做了很多的修改。所以我的建议是，如果大家使用MYSQSL，那么起码要从5.6开始使用，最好是使用5.7版本，性能是一个问题，还有后面诸多问题，例如安全性问题、高可用的问题、很多延迟性的问题都得到了ORACLE公司非常有效的解决！当然ORACLE这么做也是有他的原因的，因为太多的人去使用MARIADB了，他如果不在MYSQL上作出一些重大的突破，就没人愿意去用MYSQL了，所以他还是有了非常大的改进。当然MARIADB也有了改进，你有的功能我也有，如果用MARIADB，我建议用10版本，这个倒不是性能问题，主要是一些新特性，和安全相关的一些特性，还有功能相关的一些特性，5.5版本确实是缺少了一些非常重要的一些特性，所以建议你上10或者10.1版本。 我们的课程当中还是以mariadb的5.5版本，因为常见的基础操作不管哪个版本都一样，基础讲完了会用mysql的5.7版本或者mariadb10.1版本，讲一些他们具有的新特性。以默认版本去讲基础操作，再以新版本去讲新特性。</p>
<p>INNODB 的特性</p>
<p><img src="pic/16-mysql5.6innodb.jpg" alt="innodb"></p>
<ul>
<li>主体系结构：默认7个后台线程，4个io thread(insert buffer、log、read、write),1个master thread(优先级最高),1个锁(lock)监控线程，1个错误监控线程。可以通过<code>show engine innodb status</code>来查看。新版本已对默认的read thread和write thread分别增大到4个，可通过<code>show variables like 'innodb_io_thread%'</code>查看。</li>
</ul>
<p><img src="pic/thread01.png"></p>
<ul>
<li>存储引擎组成：缓冲池(buffer pool)、重做日志缓冲池(redo log buffer)以及额外的内存池(additional memory pool).具体配置可由<code>show variables like 'innodb_buffer_pool_size'</code>、<code>show variables like 'innodb_log_buffer_size'</code>、<code>show variables like 'innodb_additional_mem_pool_size'</code>来查看。</li>
</ul>
<p><img src="pic/thread02.png"></p>
<ul>
<li><p>缓冲池：占最大块内存，用来存放各种数据的缓存包括有索引页、数据页、undo页、插入缓冲、自适应哈希索引、innodb存储的锁信息、数据字典信息等。工作方式总是将数据库文件按页(每页16k)读取到缓冲池，然后按最近最少使用(lru)的算法来保留在缓冲池中的缓存数据。如果数据库文件需要修改，总是首先修改在缓存池中的页(发生修改后即为脏页)，然后再按照一定的频率将缓冲池的脏页刷新到文件。通过命令<code>show engine innodb status;</code>来查看。</p>
</li>
<li><p>日志缓冲：将重做日志信息先放入这个缓冲区，然后按一定频率将其刷新到重做日志文件。</p>
</li>
</ul>
<hr>
<blockquote>
<h3 id="master-thread" class="article-heading"><a href="#master-thread" class="headerlink" title="master thread:"></a><code>master thread</code>:<a class="article-anchor" href="#master-thread" aria-hidden="true"></a></h3></blockquote>
<blockquote>
<h4 id="loop主循环每秒一次的操作：" class="article-heading"><a href="#loop主循环每秒一次的操作：" class="headerlink" title="loop主循环每秒一次的操作："></a>loop主循环每秒一次的操作：<a class="article-anchor" href="#loop主循环每秒一次的操作：" aria-hidden="true"></a></h4></blockquote>
<ol>
<li>睡觉</li>
<li>将日志缓冲刷新到磁盘，即使事务未提交</li>
<li>如果【前1s的I/O次数】小于【磁盘I/O吞吐量的5% （默认200_5%=10个页）】，则合并插入缓冲（数量为磁盘I/O吞吐量_5%即10个页）</li>
<li>如果【脏页比例】大于【阀值（默认为75，脏页比例为百分之七十五）】，则刷新缓冲池中脏页到磁盘，否则只刷新合适的脏页数量（innodb_adaptive_flushing参数决定）</li>
<li>当前没有用户活动，切换到后台循环</li>
</ol>
<blockquote>
<h4 id="loop主循环每十秒一次的操作：" class="article-heading"><a href="#loop主循环每十秒一次的操作：" class="headerlink" title="loop主循环每十秒一次的操作："></a>loop主循环每十秒一次的操作：<a class="article-anchor" href="#loop主循环每十秒一次的操作：" aria-hidden="true"></a></h4></blockquote>
<ol>
<li>将日志缓冲刷新到磁盘，即使事务未提交</li>
<li>删除无用的undo页</li>
<li>合并插入缓冲，缓冲数量为【磁盘I/O吞吐量的5%，如果默认200，则合并插入缓冲10个】</li>
<li>如果【前10s的I/O次数】小于【磁盘I/O吞吐量（默认200_100%=200个页）】，则刷新缓冲池中脏页到磁盘（数量为磁盘I/O吞吐量_100%即200个页）</li>
<li>如果【脏页比例】大于【阀值（默认为75，脏页比例为百分之七十五）】，则刷新缓冲池中脏页到磁盘（数量为磁盘I/O吞吐量_100%即200个页），否则脏页刷新数量为（磁盘I/O吞吐量_10%即20个页）</li>
<li>产生一个检查点（模糊检查点）</li>
</ol>
<blockquote>
<h4 id="backgroud-loop，若当前没有用户活动-数据库空闲时-或者数据库关闭时，就会切换到这个循环：" class="article-heading"><a href="#backgroud-loop，若当前没有用户活动-数据库空闲时-或者数据库关闭时，就会切换到这个循环：" class="headerlink" title="backgroud loop，若当前没有用户活动(数据库空闲时)或者数据库关闭时，就会切换到这个循环："></a>backgroud loop，若当前没有用户活动(数据库空闲时)或者数据库关闭时，就会切换到这个循环：<a class="article-anchor" href="#backgroud-loop，若当前没有用户活动-数据库空闲时-或者数据库关闭时，就会切换到这个循环：" aria-hidden="true"></a></h4></blockquote>
<ol>
<li>删除无用的undo页</li>
<li>合并插入缓冲，缓冲数量为【磁盘I/O吞吐量的10%，如果默认200，则合并插入缓冲20个】</li>
<li>当前有用户活动，切换到主循环</li>
<li>当前没有用户活动，切换到刷新循环</li>
</ol>
<blockquote>
<h4 id="flush-loop-刷新循环，包括：" class="article-heading"><a href="#flush-loop-刷新循环，包括：" class="headerlink" title="flush loop 刷新循环，包括："></a>flush loop 刷新循环，包括：<a class="article-anchor" href="#flush-loop-刷新循环，包括：" aria-hidden="true"></a></h4></blockquote>
<ol>
<li>刷新缓冲池中脏页到磁盘（数量为磁盘I/O吞吐量*100%即200个页）</li>
<li>如果【脏页比例】大于【阀值（默认为75，脏页比例为百分之七十五）】，则继续进入刷新循环，否则进入暂停循环</li>
</ol>
<blockquote>
<h4 id="suspend-loop暂停循环，包括：" class="article-heading"><a href="#suspend-loop暂停循环，包括：" class="headerlink" title="suspend_loop暂停循环，包括："></a>suspend_loop暂停循环，包括：<a class="article-anchor" href="#suspend-loop暂停循环，包括：" aria-hidden="true"></a></h4></blockquote>
<ol>
<li>等待事件发生，进入主循环</li>
</ol>
<p><img src="pic/thread03.png"></p>
<blockquote>
<h3 id="插入缓冲：" class="article-heading"><a href="#插入缓冲：" class="headerlink" title="插入缓冲："></a><code>插入缓冲</code>：<a class="article-anchor" href="#插入缓冲：" aria-hidden="true"></a></h3></blockquote>
<p>不是缓冲池的一部分，Insert Buffer是物理页的一个组成部分,它带来InnoDB性能的提高。根据B+算法的特点，插入数据的时候主键索引是顺序的，不会造成数据库的随机读取，而对于非聚集索引(即辅助索引)，叶子节点的插入不再是顺序的了，这时需要离散地访问非聚集索引，插入性能在这里变低了。InnoDB引入插入缓冲，判断非聚集索引页是否在缓冲池中，如果在则直接插入;不在，则先放在 插入缓冲区中。然后根据上述master thread中介绍的，会有一定的频率将插入缓冲合并。此外，辅助索引不能是唯一的，因为插入到插入缓冲时，并不去查找索引页的情况，否则仍然会造成随机读，失去插入缓冲的意义了。插入缓冲可能会占缓冲池中内存，默认也能会占到1/2，所以可以将这个值调小点，到1/3。通过IBUF_POOL_SIZE_PER_MAX_SIZE来设置，2表示1/2,3表示1/3。</p>
<blockquote>
<h3 id="两次写：" class="article-heading"><a href="#两次写：" class="headerlink" title="两次写："></a><code>两次写</code>：<a class="article-anchor" href="#两次写：" aria-hidden="true"></a></h3></blockquote>
<p>它带来InnoDB数据的可靠性。如果写失效，可以通过重做日志进行恢复，但是重做日志中记录的是对页的物理操作，如果页本身损坏，再对其进行重做是没有意义的。所以，在应用重做日志前，需要一个页的副本，当写入失效发生时，先通过页的副本来还原该页，再进行重做，这就是doublewire。</p>
<p>恢复数据=页副本+重做日志</p>
<blockquote>
<h3 id="INNODB-的表" class="article-heading"><a href="#INNODB-的表" class="headerlink" title="INNODB 的表"></a>INNODB 的表<a class="article-anchor" href="#INNODB-的表" aria-hidden="true"></a></h3></blockquote>
<ol>
<li><code>表空间</code>：表空间可看做是InnoDB存储引擎逻辑结构的最高层。</li>
<li><code>段</code>：表空间由各个段组成，常见的段有数据段、索引段、回滚段等。</li>
<li><code>区</code>：由64个连续的页组成，每个页大小为16kb，即每个区大小为1MB。</li>
<li><code>页</code>：每页16kb，且不能更改。常见的页类型有：数据页、Undo页、系统页、事务数据页、插入缓冲位图页、插入缓冲空闲列表页、未压缩的二进制大对象页、压缩的二进制大对象页。</li>
<li><code>行</code>：InnoDB存储引擎是面向行的(row-oriented)，每页最多允许存放7992行数据。</li>
<li><code>行记录格式</code>：常见两种行记录格式Compact和Redundant，mysql5.1版本后，主要是Compact行记录格式。对于Compact，不管是char型还是varchar型，null型都是不占用存储空间的；对于Redudant,varchar的null不占用空间，char的null型是占用存储空间的。</li>
</ol>
<p>varchar类型的长度限制是65535，其实达不到，会有别的开销，一般是65530左右，这还跟选取的字符集有关。此外这个长度限制是一整行的，例如：<code>create table test(a varchar(22000), b varchar(22000), cvarchar(22000)) charset=latin1 engine=innodb;</code>也会报错。</p>
<p>对于blob类型的数据，在数据页面中只保存了varchar(65535)的前768个字节前缀数据，之后跟的是偏移量，指向行溢出页，也就是Uncompressed BLOB Page。新的InnoDB Plugin引入了新的文件格式称为Barracuda，其有两种新的行记录格式Compressed和Dynamic，两者对于存入Blog字段采用了完全溢出的方式，在数据库页中存放20个字节的指针，实际的数据都存入在BLOB Page中。</p>
<h2 id="事务" class="article-heading"><a href="#事务" class="headerlink" title="事务"></a>事务<a class="article-anchor" href="#事务" aria-hidden="true"></a></h2><p>事务(Transaction)是并发控制的基本单位。</p>
<p>所谓事务,它是一个操作序列,这些操作要么都执行,要么都不执行, 它是一个不可分割的工作单位。例如,银行转帐工作:从一个帐号扣款并 使另一个帐号增款,这两个操作要么都执行,要么都不执行。</p>
<p>数据库事务必须具备ACID特性,ACID是Atomic(原子性)、 Consistency(一致性)、Isolation(隔离性)和Durability(持久性)的 英文缩写。</p>
<ul>
<li>原子性:</li>
</ul>
<p>指整个数据库事务是不可分割的工作单位。只有使据库中所 有的操作执行成功,才算整个事务成功;事务中任何一个SQL语句执行失 败,那么已经执行成功的SQL语句也必须撤销,数据库状态应该退回到执 行事务前的状态。</p>
<ul>
<li>一致性:</li>
</ul>
<p>指数据库事务不能破坏关系数据的完整性以及业务逻辑上的 一致性。例如对银行转帐事务,不管事务成功还是失败,应该保证事务结 束后ACCOUNTS表中Tom和Jack的存款总额为2000元。</p>
<ul>
<li>隔离性:</li>
</ul>
<p>指的是在并发环境中,当不同的事务同时操纵相同的数据 时,每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任 何其他并发事务所做的修改隔离。事务查看数据更新时,数据所处的状态 要么是另一事务修改它之前的状态,要么是另一事务修改它之后的状态, 事务不会查看到中间状态的数据。</p>
<ul>
<li>持久性:</li>
</ul>
<p>指的是只要事务成功结束,它对数据库所做的更新就必须永 久保存下来。即使发生系统崩溃,重新启动数据库系统后,数据库还能恢 复到事务成功结束时的状态。</p>
<p>事务的(ACID)特性是由关系数据库管理系统（RDBMS）来实现的。数据库管理系统采用日志来保证事务的原子性、一致性和 持久性。日志记录了事务对数据库所做的更新,如果某个事务在执行过程 中发生错误,就可以根据日志,撤销事务对数据库已做的更新,使数据库 退回到执行事务前的初始状态。 数据库管理系统采用锁机制来实现事务的隔离性。当多个事务同时更 新数据库中相同的数据时,只允许持有锁的事务能更新该数据,其他事务 必须等待,直到前一个事务释放了锁,其他事务才有机会更新该数据。</p>
<h2 id="并发控制" class="article-heading"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制<a class="article-anchor" href="#并发控制" aria-hidden="true"></a></h2><h3 id="锁机制" class="article-heading"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制<a class="article-anchor" href="#锁机制" aria-hidden="true"></a></h3><p>InnoDB存储引擎锁的实现和Oracle非常类似，提供一致性的非锁定读、行级锁支持、行级锁没有相关的开销，可以同时得到并发性和一致性。</p>
<p>InnoDB存储引擎实现了如下两种标准的行级锁：</p>
<ol>
<li>共享锁(S Lock)：允许事务读一行数据；</li>
<li>排他锁(X Lock)：允许事务删除或者更新一行数据。</li>
</ol>
<p>当一个事务已经获得了行的共享锁，那么另外的事务可以立即获得行的共享锁，因为读取没有改变行的数据，我们称这种情况为锁兼容。但如果有事务想获得行的排他锁，则它必须等待事务释放行r上的共享锁——–这种情况称为锁不兼容。</p>
<p>在InnoDB Plugin之前，只能通过<code>SHOW FULL PROCESSLIST;</code>，<code>SHOW ENGINE INOODB STATUS;</code>等命令来查看当前的数据库请求，然后再判断当前事务中的锁的情况。新版本的InnoDB Plugin中，在INFORMATION_SCHEMA架构下添加了<code>INNODB_TRX、INNODB_LOCKS、InnoDB_LOCK_WAITS</code>。通过这三张表，可以更简单地监控当前的事务并分析可能存在的锁的问题。</p>
<p>INNODB_TRX由8个字段组成：</p>
<blockquote>
<p>通过<code>select * from infomation_schema.INNODB_TRX;</code>可查看</p>
</blockquote>
<ol>
<li>trx_id:InnoDB存储引擎内部唯一的事务ID</li>
<li>trx_state:当前事务的状态。</li>
<li>trx_started:事务的开始时间。</li>
<li>trx_requested_lock_id:等待事务的锁ID。如trx_state的状态为LOCK WAIT,那么该值代表当前的等待之前事务占用锁资源的ID.</li>
<li>若trx_state不是LOCK WAIT,则该值为NULL。</li>
<li>trx_wait_started:事务等待开始的时间。</li>
<li>trx_weight:事务的权重，反映了一个事务修改和锁住的行数。在InnoDB存储引擎中，当发生死锁需要回滚时，InnoDB存储会选 择该值最小的进行回滚。</li>
<li>trx_mysql_thread_id:Mysql中的线程ID,<code>SHOW PROCESSLIST;</code>显示的结果。</li>
<li>trx_query:事务运行的sql语句。</li>
</ol>
<p>INNODB_LOCKS表，该表由如下字段组成：</p>
<blockquote>
<p>通过<code>select * from information_schema.INNODB_LOCK;</code>可查看</p>
</blockquote>
<ol>
<li>lock_id:锁的ID。</li>
<li>lock_trx_id:事务ID。</li>
<li>lock_mode:锁的模式。</li>
<li>lock_type:锁的类型，表锁还是行锁。</li>
<li>lock_table:要加锁的表。</li>
<li>lock_index:锁的索引。</li>
<li>lock_space:InnoDB存储引擎表空间的ID号。</li>
<li>lock_page:被锁住的页的数量。若是表锁，则该值为NULL。</li>
<li>lock_rec:被锁住的行的数量。若是表锁，则该值为NULL。</li>
<li>lock_data:被锁住的行的主键值。当是表锁时，该值为NULL。</li>
</ol>
<p>INNODB_LOCK_WAIT由4个字段组成：</p>
<blockquote>
<p>通过<code>select * from information_schema.INNODB_LOCK_WAITS;</code>可查看。</p>
</blockquote>
<ol>
<li>requesting_trx_id:申请锁资源的事务ID。</li>
<li>requesting_lock_id:申请的锁的ID。</li>
<li>blocking_trx_id:阻塞的锁的ID。</li>
</ol>
<h3 id="多版本并发控制-MVCC" class="article-heading"><a href="#多版本并发控制-MVCC" class="headerlink" title="多版本并发控制 MVCC"></a>多版本并发控制 MVCC<a class="article-anchor" href="#多版本并发控制-MVCC" aria-hidden="true"></a></h3><p>InnoDB存储引擎通过行<code>多版本控制 MVCC</code>的方式来读取当前执行时间数据库中行的数据。如果读取的行正在执行Delete、update操作，这时读取操作不会因此而会等待行上锁的释放，相反，InnoDB存储引擎会去读取行的一个快照数据。快照数据是指该行之前版本的数据，该实现是通过Undo段来实现。而Undo用来事务中回滚数据，因此快照本身是没有额外开销的。此外，快照数据是不需要上锁的，因为没有必要对历史的数据进行修改。一个行可能有不止一个快照数据，所以称这种技术为行多版本技术。由此带来并发控制，称之为多版本并发控制(Multi VersionConcurrency Control, MVCC)。</p>
<h3 id="事务的隔离级别" class="article-heading"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别<a class="article-anchor" href="#事务的隔离级别" aria-hidden="true"></a></h3><p>Read uncommitted、Read committed、Repeatable read、serializable。</p>
<p>在Read Committed和Repeatable Read下，InnoDB存储引擎使用非锁定一致性读。然而，对于快照的定义却不同。在Read Committed事务隔离级别下，对于快照数据，非一致性读总是读取被锁定行的最新一份快照数据。在Repeatable事务隔离级别下，对于快照数据，非一致性读总是读取事务开始时的行数据版本。</p>
<h1 id="INNODB锁" class="article-heading"><a href="#INNODB锁" class="headerlink" title="INNODB锁"></a>INNODB锁<a class="article-anchor" href="#INNODB锁" aria-hidden="true"></a></h1><p><img src="pic/lock01.png" alt="lock01"></p>
<h2 id="设置INNODB事务隔离级别" class="article-heading"><a href="#设置INNODB事务隔离级别" class="headerlink" title="设置INNODB事务隔离级别"></a>设置INNODB事务隔离级别<a class="article-anchor" href="#设置INNODB事务隔离级别" aria-hidden="true"></a></h2><h3 id="实践1：查看innodb默认的事务隔离级别" class="article-heading"><a href="#实践1：查看innodb默认的事务隔离级别" class="headerlink" title="实践1：查看innodb默认的事务隔离级别"></a>实践1：查看innodb默认的事务隔离级别<a class="article-anchor" href="#实践1：查看innodb默认的事务隔离级别" aria-hidden="true"></a></h3><p>知识点：</p>
<ol>
<li>可以查看局部变量<code>@@tx_isolation</code>和全局变量<code>@@global.tx_isolation</code></li>
<li>局部变量在会话中生效，而全局变量是在所有会话中生效，局部覆盖全局。</li>
</ol>
<blockquote>
<p>查看当前会话中的事务隔离级别</p>
</blockquote>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"> MariaDB [(none)]&gt; select @@tx_isolation;</span><br><span class="line">+-----------------+</span><br><span class="line">| @@tx_isolation  |</span><br><span class="line">+-----------------+</span><br><span class="line">| REPEATABLE-READ |</span><br><span class="line">+-----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></tbody></table></figure>

<p>查看全局的事务隔离级别</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">MariaDB [(none)]&gt; select @@global.tx_isolation;</span><br><span class="line">+-----------------------+</span><br><span class="line">| @@global.tx_isolation |</span><br><span class="line">+-----------------------+</span><br><span class="line">| REPEATABLE-READ       |</span><br><span class="line">+-----------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; show variables like "tx_isolation";</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| Variable_name | Value           |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| tx_isolation  | REPEATABLE-READ |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; select * from information_schema.global_variables where variable_name like "%isolation%";</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| VARIABLE_NAME | VARIABLE_VALUE  |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| TX_ISOLATION  | REPEATABLE-READ |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">1 row in set (0.03 sec)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="实践2：改变单个会话的隔离级别" class="article-heading"><a href="#实践2：改变单个会话的隔离级别" class="headerlink" title="实践2：改变单个会话的隔离级别"></a>实践2：改变单个会话的隔离级别<a class="article-anchor" href="#实践2：改变单个会话的隔离级别" aria-hidden="true"></a></h3><p>知识点：</p>
<p>1.用户可以用SET TRANSACTION语句改变单个会话的隔离级别。</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">SET SESSION  TRANSACTION ISOLATION LEVEL</span><br><span class="line">                       {READ UNCOMMITTED | READ COMMITTED</span><br><span class="line">                        | REPEATABLE READ | SERIALIZABLE}</span><br></pre></td></tr></tbody></table></figure>

<p>2.会话结束重新开启新的会话，则使用全局变量的值</p>
<p>session1设置RR</p>
<p>由于默认的隔离级别就是RR，因此不用设置，查看一下即可</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">MariaDB [(none)]&gt; select @@tx_isolation;</span><br><span class="line">+-----------------+</span><br><span class="line">| @@tx_isolation  |</span><br><span class="line">+-----------------+</span><br><span class="line">| REPEATABLE-READ |</span><br><span class="line">+-----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></tbody></table></figure>

<p>session2设置RC</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">MariaDB [information_schema]&gt; select @@tx_isolation;</span><br><span class="line">+-----------------+</span><br><span class="line">| @@tx_isolation  |</span><br><span class="line">+-----------------+</span><br><span class="line">| REPEATABLE-READ |</span><br><span class="line">+-----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [information_schema]&gt; set session transaction isolation level read committed;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [information_schema]&gt; select @@tx_isolation;</span><br><span class="line">+----------------+</span><br><span class="line">| @@tx_isolation |</span><br><span class="line">+----------------+</span><br><span class="line">| READ-COMMITTED |</span><br><span class="line">+----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></tbody></table></figure>

<p>session2结束会话，开启新的session3</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">MariaDB [information_schema]&gt; exit</span><br><span class="line">Bye</span><br><span class="line">[root@localhost ~]# mysql</span><br><span class="line">Welcome to the MariaDB monitor.  Commands end with ; or \g.</span><br><span class="line">Your MariaDB connection id is 6</span><br><span class="line">Server version: 5.5.44-MariaDB MariaDB Server</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2015, Oracle, MariaDB Corporation Ab and others.</span><br><span class="line"></span><br><span class="line">Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; select @@tx_isolation;</span><br><span class="line">+-----------------+</span><br><span class="line">| @@tx_isolation  |</span><br><span class="line">+-----------------+</span><br><span class="line">| REPEATABLE-READ |</span><br><span class="line">+-----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="实践3：改变单个实例的隔离级别" class="article-heading"><a href="#实践3：改变单个实例的隔离级别" class="headerlink" title="实践3：改变单个实例的隔离级别"></a>实践3：改变单个实例的隔离级别<a class="article-anchor" href="#实践3：改变单个实例的隔离级别" aria-hidden="true"></a></h3><p>知识点：</p>
<p>1.用户可以用SET TRANSACTION语句改变单个实例的隔离级别。</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">SET GLOBAL  TRANSACTION ISOLATION LEVEL</span><br><span class="line">                       {READ UNCOMMITTED | READ COMMITTED</span><br><span class="line">                        | REPEATABLE READ | SERIALIZABLE}</span><br></pre></td></tr></tbody></table></figure>

<p>2.实例结束重新开启新的实例，则使用配置文件中的参数值，或程序编译时的参数值。</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">MariaDB [(none)]&gt; set global transaction isolation level read committed;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; select @@tx_isolation;</span><br><span class="line">+-----------------+</span><br><span class="line">| @@tx_isolation  |</span><br><span class="line">+-----------------+</span><br><span class="line">| REPEATABLE-READ |</span><br><span class="line">+-----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; select @@global.tx_isolation;</span><br><span class="line">+-----------------------+</span><br><span class="line">| @@global.tx_isolation |</span><br><span class="line">+-----------------------+</span><br><span class="line">| READ-COMMITTED        |</span><br><span class="line">+-----------------------+</span><br><span class="line">1 row in set (0.00 sec).</span><br></pre></td></tr></tbody></table></figure>

<p>当前会话中，局部变量的值为RR，全局变量的值为RC，而局部会覆盖全局，所以当前会话中的隔离级别还是RR，我们需要退出当前会话，开启新的会话。</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">[root@localhost ~]# mysql</span><br><span class="line">Welcome to the MariaDB monitor.  Commands end with ; or \g.</span><br><span class="line">Your MariaDB connection id is 8</span><br><span class="line">Server version: 5.5.44-MariaDB MariaDB Server</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2015, Oracle, MariaDB Corporation Ab and others.</span><br><span class="line"></span><br><span class="line">Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; select @@tx_isolation;</span><br><span class="line">+----------------+</span><br><span class="line">| @@tx_isolation |</span><br><span class="line">+----------------+</span><br><span class="line">| READ-COMMITTED |</span><br><span class="line">+----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; select @@global.tx_isolation;</span><br><span class="line">+-----------------------+</span><br><span class="line">| @@global.tx_isolation |</span><br><span class="line">+-----------------------+</span><br><span class="line">| READ-COMMITTED        |</span><br><span class="line">+-----------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></tbody></table></figure>

<p>在会话中通过修改全局变量的方式，只能让当前的实例生效，如果服务重启了，则失效。</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">[root@localhost ~]# systemctl restart mariadb</span><br><span class="line">[root@localhost ~]# mysql</span><br><span class="line">Welcome to the MariaDB monitor.  Commands end with ; or \g.</span><br><span class="line">Your MariaDB connection id is 2</span><br><span class="line">Server version: 5.5.44-MariaDB MariaDB Server</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2015, Oracle, MariaDB Corporation Ab and others.</span><br><span class="line"></span><br><span class="line">Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; select @@tx_isolation;</span><br><span class="line">+-----------------+</span><br><span class="line">| @@tx_isolation  |</span><br><span class="line">+-----------------+</span><br><span class="line">| REPEATABLE-READ |</span><br><span class="line">+-----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; select @@global.tx_isolation;</span><br><span class="line">+-----------------------+</span><br><span class="line">| @@global.tx_isolation |</span><br><span class="line">+-----------------------+</span><br><span class="line">| REPEATABLE-READ       |</span><br><span class="line">+-----------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="实践4：改变所有实例的隔离级别" class="article-heading"><a href="#实践4：改变所有实例的隔离级别" class="headerlink" title="实践4：改变所有实例的隔离级别"></a>实践4：改变所有实例的隔离级别<a class="article-anchor" href="#实践4：改变所有实例的隔离级别" aria-hidden="true"></a></h3><p>知识点：</p>
<p>1.修改配置文件，为所有实例和连接设置默认隔离级别。</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">transaction-isolation = {READ-UNCOMMITTED | READ-COMMITTED</span><br><span class="line">                         | REPEATABLE-READ | SERIALIZABLE}</span><br></pre></td></tr></tbody></table></figure>

<p>2.innodb默认的隔离级别为 REPEATABLE-READ</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/my.cnf</span><br><span class="line">transaction-isolation=read-committed</span><br><span class="line">[root@localhost ~]# systemctl restart mariadb</span><br><span class="line">[root@localhost ~]# mysql -e "select @@tx_isolation"</span><br><span class="line">+----------------+</span><br><span class="line">| @@tx_isolation |</span><br><span class="line">+----------------+</span><br><span class="line">| READ-COMMITTED |</span><br><span class="line">+----------------+</span><br><span class="line">[root@localhost ~]# mysql -e "select @@global.tx_isolation"</span><br><span class="line">+-----------------------+</span><br><span class="line">| @@global.tx_isolation |</span><br><span class="line">+-----------------------+</span><br><span class="line">| READ-COMMITTED        |</span><br><span class="line">+-----------------------+</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h2 id="区分INNODB事务隔离级别" class="article-heading"><a href="#区分INNODB事务隔离级别" class="headerlink" title="区分INNODB事务隔离级别"></a>区分INNODB事务隔离级别<a class="article-anchor" href="#区分INNODB事务隔离级别" aria-hidden="true"></a></h2><p><img src="pic/lock02.png" alt="lock02"></p>
<h3 id="InnoDB-中的隔离级详细描述" class="article-heading"><a href="#InnoDB-中的隔离级详细描述" class="headerlink" title="InnoDB 中的隔离级详细描述"></a>InnoDB 中的隔离级详细描述<a class="article-anchor" href="#InnoDB-中的隔离级详细描述" aria-hidden="true"></a></h3><ul>
<li><code>READ UNCOMMITTED</code> 这通常称为 ‘dirty read’：non-locking SELECTs 的执行使我们不会看到一个记录的可能更早的版本；因而在这个隔离度下是非 ‘consistent’ reads；另外，这级隔离的运作如同 READ COMMITTED。</li>
<li><code>READ COMMITTED</code> 有些类似 Oracle 的隔离级。所有 SELECT … FOR UPDATE 和 SELECT … LOCK IN SHARE MODE 语句只锁定索引记录，而不锁定之前的间隙，因而允许在锁定的记录后自由地插入新记录。以一个唯一地搜索条件使用一个唯一索引(unique index)的 UPDATE 和 DELETE，仅仅只锁定所找到的索引记录，而不锁定该索引之前的间隙。但是在范围型的 UPDATE and DELETE中，InnoDB 必须设置 next-key 或 gap locks 来阻塞其它用户对范围内的空隙插入。 自从为了 MySQL 进行复制(replication)与恢复(recovery)工作’phantom rows’必须被阻塞以来，这就是必须的了。Consistent reads 运作方式与 Oracle 有点类似： 每一个 consistent read，甚至是同一个事务中的，均设置并作用它自己的最新快照。</li>
<li><code>REPEATABLE READ</code> 这是 InnoDB 默认的事务隔离级。. SELECT … FOR UPDATE, SELECT … LOCK IN SHARE MODE, UPDATE, 和 DELETE ，这些以唯一条件搜索唯一索引的，只锁定所找到的索引记录，而不锁定该索引之前的间隙。 否则这些操作将使用 next-key 锁定，以 next-key 和 gap locks 锁定找到的索引范围，并阻塞其它用户的新建插入。在 consistent reads 中，与前一个隔离级相比这是一个重要的差别： 在这一级中，同一事务中所有的 consistent reads 均读取第一次读取时已确定的快照。这个约定就意味着如果在同一事务中发出几个无格式(plain)的SELECTs ，这些 SELECTs 的相互关系是一致的。</li>
<li><code>SERIALIZABLE</code> 这一级与上一级相似，只是无格式(plain)的 SELECTs 被隐含地转换为 SELECT … LOCK IN SHARE MODE。</li>
</ul>
<h3 id="实践1：SERIALIZABLE隔离级别查询自动加共享锁" class="article-heading"><a href="#实践1：SERIALIZABLE隔离级别查询自动加共享锁" class="headerlink" title="实践1：SERIALIZABLE隔离级别查询自动加共享锁"></a>实践1：SERIALIZABLE隔离级别查询自动加共享锁<a class="article-anchor" href="#实践1：SERIALIZABLE隔离级别查询自动加共享锁" aria-hidden="true"></a></h3><ul>
<li>开启四个会话session1-4，分别设置不同的隔离级别</li>
</ul>
<p><img src="pic/lock03.png" alt="lock03"></p>
<ul>
<li>再开启一个会话session5默认使用RR隔离级别</li>
</ul>
<p><img src="pic/lock04.png" alt="lock04"></p>
<ul>
<li>session1-5都开启一个事务，查看test库中t1表中id=100的行</li>
</ul>
<p><img src="pic/lock05.png" alt="lock05"></p>
<ul>
<li>session5中将id=100的行改为200，发现出现死锁，这是因为session4为SERIALIZABLE，查看id=100的行会被加上一个共享锁S，而其他三种模式都是不加锁的，使用一致性非锁定读。</li>
</ul>
<p><img src="pic/lock06.png" alt="lock06"></p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">MariaDB [(none)]&gt; select * from information_schema.innodb_locks\G;</span><br><span class="line">*************************** 1\. row ***************************</span><br><span class="line">    lock_id: 909:0:308:2</span><br><span class="line">lock_trx_id: 909</span><br><span class="line">  lock_mode: X</span><br><span class="line">  lock_type: RECORD</span><br><span class="line"> lock_table: `test`.`t1`</span><br><span class="line"> lock_index: `PRIMARY`</span><br><span class="line"> lock_space: 0</span><br><span class="line">  lock_page: 308</span><br><span class="line">   lock_rec: 2</span><br><span class="line">  lock_data: 100</span><br><span class="line">*************************** 2\. row ***************************</span><br><span class="line">    lock_id: 90A:0:308:2</span><br><span class="line">lock_trx_id: 90A</span><br><span class="line">  lock_mode: S</span><br><span class="line">  lock_type: RECORD</span><br><span class="line"> lock_table: `test`.`t1`</span><br><span class="line"> lock_index: `PRIMARY`</span><br><span class="line"> lock_space: 0</span><br><span class="line">  lock_page: 308</span><br><span class="line">   lock_rec: 2</span><br><span class="line">  lock_data: 100</span><br><span class="line">2 rows in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">ERROR: No query specified</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; select * from information_schema.innodb_lock_waits\G;</span><br><span class="line">*************************** 1\. row ***************************</span><br><span class="line">requesting_trx_id: 909</span><br><span class="line">requested_lock_id: 909:0:308:2</span><br><span class="line">  blocking_trx_id: 90A</span><br><span class="line"> blocking_lock_id: 90A:0:308:2</span><br><span class="line">1 row in set (0.04 sec)</span><br><span class="line"></span><br><span class="line">ERROR: No query specified</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; select * from information_schema.innodb_trx\G;</span><br><span class="line">*************************** 1\. row ***************************</span><br><span class="line">                    trx_id: 90A</span><br><span class="line">                 trx_state: RUNNING</span><br><span class="line">               trx_started: 2016-12-15 17:08:01</span><br><span class="line">     trx_requested_lock_id: NULL</span><br><span class="line">          trx_wait_started: NULL</span><br><span class="line">                trx_weight: 2</span><br><span class="line">       trx_mysql_thread_id: 5</span><br><span class="line">                 trx_query: NULL</span><br><span class="line">       trx_operation_state: NULL</span><br><span class="line">         trx_tables_in_use: 0</span><br><span class="line">         trx_tables_locked: 0</span><br><span class="line">          trx_lock_structs: 2</span><br><span class="line">     trx_lock_memory_bytes: 376</span><br><span class="line">           trx_rows_locked: 1</span><br><span class="line">         trx_rows_modified: 0</span><br><span class="line">   trx_concurrency_tickets: 0</span><br><span class="line">       trx_isolation_level: SERIALIZABLE</span><br><span class="line">         trx_unique_checks: 1</span><br><span class="line">    trx_foreign_key_checks: 1</span><br><span class="line">trx_last_foreign_key_error: NULL</span><br><span class="line"> trx_adaptive_hash_latched: 0</span><br><span class="line"> trx_adaptive_hash_timeout: 10000</span><br><span class="line">*************************** 2\. row ***************************</span><br><span class="line">                    trx_id: 909</span><br><span class="line">                 trx_state: LOCK WAIT</span><br><span class="line">               trx_started: 2016-12-15 17:02:04</span><br><span class="line">     trx_requested_lock_id: 909:0:308:2</span><br><span class="line">          trx_wait_started: 2016-12-15 17:10:18</span><br><span class="line">                trx_weight: 2</span><br><span class="line">       trx_mysql_thread_id: 4</span><br><span class="line">                 trx_query: update test.t1 set id=200 where id=100</span><br><span class="line">       trx_operation_state: starting index read</span><br><span class="line">         trx_tables_in_use: 1</span><br><span class="line">         trx_tables_locked: 1</span><br><span class="line">          trx_lock_structs: 2</span><br><span class="line">     trx_lock_memory_bytes: 1248</span><br><span class="line">           trx_rows_locked: 1</span><br><span class="line">         trx_rows_modified: 0</span><br><span class="line">   trx_concurrency_tickets: 0</span><br><span class="line">       trx_isolation_level: REPEATABLE READ</span><br><span class="line">         trx_unique_checks: 1</span><br><span class="line">    trx_foreign_key_checks: 1</span><br><span class="line">trx_last_foreign_key_error: NULL</span><br><span class="line"> trx_adaptive_hash_latched: 0</span><br><span class="line"> trx_adaptive_hash_timeout: 10000</span><br><span class="line">*************************** 3\. row ***************************</span><br><span class="line">                    trx_id: 908</span><br><span class="line">                 trx_state: RUNNING</span><br><span class="line">               trx_started: 2016-12-15 17:02:02</span><br><span class="line">     trx_requested_lock_id: NULL</span><br><span class="line">          trx_wait_started: NULL</span><br><span class="line">                trx_weight: 0</span><br><span class="line">       trx_mysql_thread_id: 3</span><br><span class="line">                 trx_query: NULL</span><br><span class="line">       trx_operation_state: NULL</span><br><span class="line">         trx_tables_in_use: 0</span><br><span class="line">         trx_tables_locked: 0</span><br><span class="line">          trx_lock_structs: 0</span><br><span class="line">     trx_lock_memory_bytes: 376</span><br><span class="line">           trx_rows_locked: 0</span><br><span class="line">         trx_rows_modified: 0</span><br><span class="line">   trx_concurrency_tickets: 0</span><br><span class="line">       trx_isolation_level: READ COMMITTED</span><br><span class="line">         trx_unique_checks: 1</span><br><span class="line">    trx_foreign_key_checks: 1</span><br><span class="line">trx_last_foreign_key_error: NULL</span><br><span class="line"> trx_adaptive_hash_latched: 0</span><br><span class="line"> trx_adaptive_hash_timeout: 10000</span><br><span class="line">*************************** 4\. row ***************************</span><br><span class="line">                    trx_id: 906</span><br><span class="line">                 trx_state: RUNNING</span><br><span class="line">               trx_started: 2016-12-15 17:01:57</span><br><span class="line">     trx_requested_lock_id: NULL</span><br><span class="line">          trx_wait_started: NULL</span><br><span class="line">                trx_weight: 0</span><br><span class="line">       trx_mysql_thread_id: 6</span><br><span class="line">                 trx_query: NULL</span><br><span class="line">       trx_operation_state: NULL</span><br><span class="line">         trx_tables_in_use: 0</span><br><span class="line">         trx_tables_locked: 0</span><br><span class="line">          trx_lock_structs: 0</span><br><span class="line">     trx_lock_memory_bytes: 376</span><br><span class="line">           trx_rows_locked: 0</span><br><span class="line">         trx_rows_modified: 0</span><br><span class="line">   trx_concurrency_tickets: 0</span><br><span class="line">       trx_isolation_level: REPEATABLE READ</span><br><span class="line">         trx_unique_checks: 1</span><br><span class="line">    trx_foreign_key_checks: 1</span><br><span class="line">trx_last_foreign_key_error: NULL</span><br><span class="line"> trx_adaptive_hash_latched: 0</span><br><span class="line"> trx_adaptive_hash_timeout: 10000</span><br><span class="line">*************************** 5\. row ***************************</span><br><span class="line">                    trx_id: 905</span><br><span class="line">                 trx_state: RUNNING</span><br><span class="line">               trx_started: 2016-12-15 17:01:39</span><br><span class="line">     trx_requested_lock_id: NULL</span><br><span class="line">          trx_wait_started: NULL</span><br><span class="line">                trx_weight: 0</span><br><span class="line">       trx_mysql_thread_id: 2</span><br><span class="line">                 trx_query: select * from information_schema.innodb_trx</span><br><span class="line">       trx_operation_state: NULL</span><br><span class="line">         trx_tables_in_use: 0</span><br><span class="line">         trx_tables_locked: 0</span><br><span class="line">          trx_lock_structs: 0</span><br><span class="line">     trx_lock_memory_bytes: 376</span><br><span class="line">           trx_rows_locked: 0</span><br><span class="line">         trx_rows_modified: 0</span><br><span class="line">   trx_concurrency_tickets: 0</span><br><span class="line">       trx_isolation_level: READ UNCOMMITTED</span><br><span class="line">         trx_unique_checks: 1</span><br><span class="line">    trx_foreign_key_checks: 1</span><br><span class="line">trx_last_foreign_key_error: NULL</span><br><span class="line"> trx_adaptive_hash_latched: 0</span><br><span class="line"> trx_adaptive_hash_timeout: 10000</span><br><span class="line">5 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">ERROR: No query specified</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>session4中提交事务，则id=100的行锁被解除，我们关闭session4，下图为最新的情况</li>
</ul>
<p><img src="pic/lock07.png" alt="lock07"></p>
<h3 id="实践2：RU、RC、RR隔离级别的对比" class="article-heading"><a href="#实践2：RU、RC、RR隔离级别的对比" class="headerlink" title="实践2：RU、RC、RR隔离级别的对比"></a>实践2：RU、RC、RR隔离级别的对比<a class="article-anchor" href="#实践2：RU、RC、RR隔离级别的对比" aria-hidden="true"></a></h3><ul>
<li>session5，修改id=100的行，改为200，不提交事务，session1-,3分别查看id=100的值，观察情况</li>
</ul>
<p><img src="pic/lock08.png" alt="lock08"></p>
<ul>
<li>RU级别的会话中的事务在session5中事务未提交的情况下，就能够查看到最新的行记录了</li>
</ul>
<p><img src="pic/lock09.png" alt="lock09"></p>
<ul>
<li>RC级别的会话中的事务在session5会话的事务提交后就能够查看到最新的行记录了</li>
</ul>
<p><img src="pic/lock10.png" alt="lock10"></p>
<ul>
<li>RR级别的会话中必须在session5的事务提交后并且自己的事务也提交后才能查到最新的行记录</li>
</ul>
<h2 id="实现一致性锁定读" class="article-heading"><a href="#实现一致性锁定读" class="headerlink" title="实现一致性锁定读"></a>实现一致性锁定读<a class="article-anchor" href="#实现一致性锁定读" aria-hidden="true"></a></h2><p>InnoDB默认是可重复读的（REPEATABLE READ），MVCC多版本并发控制，实现一致性地非锁定读操作。</p>
<p>InnoDB存储引擎的select操作使用一致性非锁定读；也就是说，select操作不会去请求共享锁S；</p>
<p>如何显示地使用一致性锁定读呢？</p>
<ul>
<li>第一种方法，显式地加共享锁S：select * from t1 where id=1 lock on share mode;</li>
<li>第二种方法，显式地加排他锁X：select * from t1 where id=1 for update;</li>
</ul>
<h3 id="实践1：设置innodb申请锁等待超时时间" class="article-heading"><a href="#实践1：设置innodb申请锁等待超时时间" class="headerlink" title="实践1：设置innodb申请锁等待超时时间"></a>实践1：设置innodb申请锁等待超时时间<a class="article-anchor" href="#实践1：设置innodb申请锁等待超时时间" aria-hidden="true"></a></h3><p><img src="pic/lock13.png" alt="lock13"></p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">MariaDB [(none)]&gt; set @@innodb_lock_wait_timeout=3;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="实践2：设置一致性锁定读，加共享锁测试" class="article-heading"><a href="#实践2：设置一致性锁定读，加共享锁测试" class="headerlink" title="实践2：设置一致性锁定读，加共享锁测试"></a>实践2：设置一致性锁定读，加共享锁测试<a class="article-anchor" href="#实践2：设置一致性锁定读，加共享锁测试" aria-hidden="true"></a></h3><p><img src="pic/lock16.png" alt="lock16"></p>
<p>打开两个会话，分别按照图片中去做测试</p>
<p><img src="pic/lock14.png" alt="lock14"></p>
<p>从实践中可以得到以下信息:</p>
<ul>
<li>事务A对id=1的行申请了共享S锁之后，事务B要么使用一致性非锁定读，即不请求锁，或者使用一致性锁定读的共享锁，即请求共享S锁</li>
<li>而事务B中需要请求排他锁的写操作都不能执行，每次都是锁请求等待超时</li>
</ul>
<h3 id="实践3：设置一致性锁定读，加排他锁测试" class="article-heading"><a href="#实践3：设置一致性锁定读，加排他锁测试" class="headerlink" title="实践3：设置一致性锁定读，加排他锁测试"></a>实践3：设置一致性锁定读，加排他锁测试<a class="article-anchor" href="#实践3：设置一致性锁定读，加排他锁测试" aria-hidden="true"></a></h3><p><img src="pic/lock17.png" alt="lock17"></p>
<p>这一次事务A以及对id=1的行申请了排他锁X，按照下图做测试：</p>
<p><img src="pic/lock15.png" alt="lock15"></p>
<p>从实践中可以得到以下信息:</p>
<ul>
<li>事务A对id=1的行申请了排他锁X之后，事务B只能使用一致性非锁定读，即不请求锁</li>
<li>而事务B中需要请求锁的行为都会等待超时，包括排他锁的写操作和共享锁的读操作都不能执行</li>
</ul>
<h2 id="认识锁的算法" class="article-heading"><a href="#认识锁的算法" class="headerlink" title="认识锁的算法"></a>认识锁的算法<a class="article-anchor" href="#认识锁的算法" aria-hidden="true"></a></h2><p>nnoDB存储引擎的锁的算法有三种：</p>
<ul>
<li>Record lock：单个行记录上的锁</li>
<li>Gap lock：间隙锁，锁定一个范围，不包括记录本身</li>
<li>Next-key lock：record+gap 锁定一个范围，包含记录本身</li>
</ul>
<p>Lock的精度（type）分为 行锁、表锁、意向锁</p>
<p>Lock的模式（mode）分为:</p>
<ul>
<li>锁的类型 —-【读锁和写锁】或者【共享锁和排他锁】即 【X or S】</li>
<li>锁的范围 —-【record lock、gap lock、Next-key lock】</li>
</ul>
<h3 id="知识点" class="article-heading"><a href="#知识点" class="headerlink" title="知识点"></a>知识点<a class="article-anchor" href="#知识点" aria-hidden="true"></a></h3><ol>
<li>innodb对于行的查询使用next-key lock</li>
<li>Next-locking keying为了解决Phantom Problem幻读问题</li>
<li>当查询的索引含有唯一属性时，将next-key lock降级为record key</li>
<li>Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生</li>
<li>有两种方式显式关闭gap锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock） A. 将事务隔离级别设置为RC B. 将参数innodb_locks_unsafe_for_binlog设置为1</li>
</ol>
<p><img src="pic/lock18.png" alt="lock18"></p>
<h3 id="实践1：-验证next-key-lock降级为record-key" class="article-heading"><a href="#实践1：-验证next-key-lock降级为record-key" class="headerlink" title="实践1： 验证next-key lock降级为record key"></a>实践1： 验证next-key lock降级为record key<a class="article-anchor" href="#实践1：-验证next-key-lock降级为record-key" aria-hidden="true"></a></h3><p>创建db1.t1表，有列a和b，分别为char(10)和int型，并且b为key，注意b列为索引列，但并不是主键，因此不是唯一的。</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">MariaDB [db1]&gt; create table db1.t1 (a char(10),b int,key (b));</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [db1]&gt; insert into db1.t1 values ('batman',1),('superman',3),('leo',5);</span><br><span class="line">Query OK, 3 rows affected (0.15 sec)</span><br><span class="line">Records: 3  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">MariaDB [db1]&gt; select * from db1.t1;</span><br><span class="line">+----------+------+</span><br><span class="line">| a        | b    |</span><br><span class="line">+----------+------+</span><br><span class="line">| batman   |    1 |</span><br><span class="line">| superman |    3 |</span><br><span class="line">| leo      |    5 |</span><br><span class="line">+----------+------+</span><br><span class="line">3 rows in set (0.02 sec)</span><br></pre></td></tr></tbody></table></figure>

<p>接下来开启两个事务T1和T2，T1中查看b=3的行，显式加排他锁；T1未提交事务时，T2事务开启并尝试插入新行a=’batman’,b=2和a=’batman’,b=4；</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">事务T1</span></span><br><span class="line">MariaDB [db1]&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [db1]&gt; select * from db1.t1 where b=3 for update;</span><br><span class="line">+----------+------+</span><br><span class="line">| a        | b    |</span><br><span class="line">+----------+------+</span><br><span class="line">| superman |    3 |</span><br><span class="line">+----------+------+</span><br><span class="line">1 row in set (0.12 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">事务T2</span></span><br><span class="line">MariaDB [db1]&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [db1]&gt; insert into db1.t1 values ('batman',2);</span><br><span class="line">ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction</span><br><span class="line">MariaDB [db1]&gt; insert into db1.t1 values ('batman',4);</span><br><span class="line">ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction</span><br></pre></td></tr></tbody></table></figure>

<p>发现T2事务中不能插入新行a=’batman’,b=2和a=’batman’,b=4；可以查看当前innodb锁的信息</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">MariaDB [db1]&gt; select * from information_schema.innodb_locks\G;</span><br><span class="line">*************************** 1\. row ***************************</span><br><span class="line">    lock_id: 111B:0:334:3</span><br><span class="line">lock_trx_id: 111B</span><br><span class="line">  lock_mode: X,GAP</span><br><span class="line">  lock_type: RECORD</span><br><span class="line"> lock_table: `db1`.`t1`</span><br><span class="line"> lock_index: `b`</span><br><span class="line"> lock_space: 0</span><br><span class="line">  lock_page: 334</span><br><span class="line">   lock_rec: 3</span><br><span class="line">  lock_data: 3, 0x00000000020E</span><br><span class="line">*************************** 2\. row ***************************</span><br><span class="line">    lock_id: 111A:0:334:3</span><br><span class="line">lock_trx_id: 111A</span><br><span class="line">  lock_mode: X</span><br><span class="line">  lock_type: RECORD</span><br><span class="line"> lock_table: `db1`.`t1`</span><br><span class="line"> lock_index: `b`</span><br><span class="line"> lock_space: 0</span><br><span class="line">  lock_page: 334</span><br><span class="line">   lock_rec: 3</span><br><span class="line">  lock_data: 3, 0x00000000020E</span><br><span class="line">2 rows in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">ERROR: No query specified</span><br><span class="line"></span><br><span class="line">MariaDB [db1]&gt; select * from information_schema.innodb_lock_waits\G;</span><br><span class="line">*************************** 1\. row ***************************</span><br><span class="line">requesting_trx_id: 111B</span><br><span class="line">requested_lock_id: 111B:0:334:3</span><br><span class="line">  blocking_trx_id: 111A</span><br><span class="line"> blocking_lock_id: 111A:0:334:3</span><br><span class="line">1 row in set (0.09 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [db1]&gt; select * from information_schema.innodb_lock_waits\G;</span><br><span class="line">*************************** 1\. row ***************************</span><br><span class="line">requesting_trx_id: 111B</span><br><span class="line">requested_lock_id: 111B:0:334:4</span><br><span class="line">  blocking_trx_id: 111A</span><br><span class="line"> blocking_lock_id: 111A:0:334:4</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">ERROR: No query specified</span><br><span class="line"></span><br><span class="line">MariaDB [db1]&gt; select * from information_schema.innodb_locks\G;</span><br><span class="line">*************************** 1\. row ***************************</span><br><span class="line">    lock_id: 111B:0:334:4</span><br><span class="line">lock_trx_id: 111B</span><br><span class="line">  lock_mode: X,GAP</span><br><span class="line">  lock_type: RECORD</span><br><span class="line"> lock_table: `db1`.`t1`</span><br><span class="line"> lock_index: `b`</span><br><span class="line"> lock_space: 0</span><br><span class="line">  lock_page: 334</span><br><span class="line">   lock_rec: 4</span><br><span class="line">  lock_data: 5, 0x00000000020F</span><br><span class="line">*************************** 2\. row ***************************</span><br><span class="line">    lock_id: 111A:0:334:4</span><br><span class="line">lock_trx_id: 111A</span><br><span class="line">  lock_mode: X,GAP</span><br><span class="line">  lock_type: RECORD</span><br><span class="line"> lock_table: `db1`.`t1`</span><br><span class="line"> lock_index: `b`</span><br><span class="line"> lock_space: 0</span><br><span class="line">  lock_page: 334</span><br><span class="line">   lock_rec: 4</span><br><span class="line">  lock_data: 5, 0x00000000020F</span><br><span class="line">2 rows in set (0.11 sec)</span><br><span class="line"></span><br><span class="line">ERROR: No query specified</span><br></pre></td></tr></tbody></table></figure>

<p>我们看到T2事务的两次插入动作都在请求排他锁，但是此时T1事务已经在加了next-key lock(record + gap)，表现范围为b的(1,5)，包括记录3，所以T2事务在T1事务解锁之间，不能插入到b的(1,5)范围内</p>
<p>× <code>lock_mode: X,GAP</code> lock_mode 可以理解为 <code>读锁还是写锁？</code>；<code>是在什么范围上锁？</code>;此处加的写锁即排他锁；范围是(1,5)</p>
<ul>
<li><code>lock_type: RECORD</code> 表示锁的精度，根据存储引擎不同，innodb是行锁，MYISAM是表锁</li>
</ul>
<p>删除db1.t1表，重新创建db1.t1表，有列a和b，分别为char(10)和int型，并且b为primay key，因此b列是唯一的。</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">MariaDB [db1]&gt; drop tables t1;</span><br><span class="line">Query OK, 0 rows affected (0.12 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [db1]&gt; create table db1.t1 (a char(10),b int ,primary key (b));</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [db1]&gt; insert into db1.t1 values ('batman',1),('superman',3),('leo',5);</span><br><span class="line">Query OK, 3 rows affected (0.12 sec)</span><br><span class="line">Records: 3  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">MariaDB [db1]&gt; select * from db1.t1;</span><br><span class="line">+----------+---+</span><br><span class="line">| a        | b |</span><br><span class="line">+----------+---+</span><br><span class="line">| batman   | 1 |</span><br><span class="line">| superman | 3 |</span><br><span class="line">| leo      | 5 |</span><br><span class="line">+----------+---+</span><br><span class="line">3 rows in set (0.08 sec)</span><br></pre></td></tr></tbody></table></figure>

<p>接下来开启两个事务T1和T2，T1中查看b=3的行，显式加排他锁；T1未提交事务时，T2事务开启并尝试插入新行a=’batman’,b=2和a=’batman’,b=4；</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">事务T1</span></span><br><span class="line">MariaDB [db1]&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [db1]&gt; select * from db1.t1 where b=3 for update;</span><br><span class="line">+----------+---+</span><br><span class="line">| a        | b |</span><br><span class="line">+----------+---+</span><br><span class="line">| superman | 3 |</span><br><span class="line">+----------+---+</span><br><span class="line">1 row in set (0.14 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">事务T2</span></span><br><span class="line">MariaDB [db1]&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [db1]&gt; insert into db1.t1 values ('batman',2);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [db1]&gt; insert into db1.t1 values ('batman',4);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br></pre></td></tr></tbody></table></figure>

<p>继续在T2事务中尝试查看b=3的行，显式加共享锁。</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">事务T2</span></span><br><span class="line">MariaDB [db1]&gt; select * from db1.t1 where b=3 lock in share mode;</span><br><span class="line">ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction</span><br></pre></td></tr></tbody></table></figure>

<p>发现T2事务中可以插入新行a=’batman’,b=2和a=’batman’,b=4；但是不能查看b=3的行，接下来我们查看当前innodb锁的信息</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">MariaDB [db1]&gt; select * from information_schema.innodb_locks\G;</span><br><span class="line">*************************** 1\. row ***************************</span><br><span class="line">    lock_id: 1122:0:337:3</span><br><span class="line">lock_trx_id: 1122</span><br><span class="line">  lock_mode: S</span><br><span class="line">  lock_type: RECORD</span><br><span class="line"> lock_table: `db1`.`t1`</span><br><span class="line"> lock_index: `PRIMARY`</span><br><span class="line"> lock_space: 0</span><br><span class="line">  lock_page: 337</span><br><span class="line">   lock_rec: 3</span><br><span class="line">  lock_data: 3</span><br><span class="line">*************************** 2\. row ***************************</span><br><span class="line">    lock_id: 1121:0:337:3</span><br><span class="line">lock_trx_id: 1121</span><br><span class="line">  lock_mode: X</span><br><span class="line">  lock_type: RECORD</span><br><span class="line"> lock_table: `db1`.`t1`</span><br><span class="line"> lock_index: `PRIMARY`</span><br><span class="line"> lock_space: 0</span><br><span class="line">  lock_page: 337</span><br><span class="line">   lock_rec: 3</span><br><span class="line">  lock_data: 3</span><br><span class="line">2 rows in set (0.02 sec)</span><br><span class="line"></span><br><span class="line">ERROR: No query specified</span><br><span class="line"></span><br><span class="line">MariaDB [db1]&gt; select * from information_schema.innodb_lock_waits\G;</span><br><span class="line">*************************** 1\. row ***************************</span><br><span class="line">requesting_trx_id: 1122</span><br><span class="line">requested_lock_id: 1122:0:337:3</span><br><span class="line">  blocking_trx_id: 1121</span><br><span class="line"> blocking_lock_id: 1121:0:337:3</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">ERROR: No query specified</span><br></pre></td></tr></tbody></table></figure>

<p>从以上信息可以看到，T1事务当前只在b=3所在的行上加了写锁，排他锁，并没有同时使用gap锁来组成next-key lock。</p>
<p>到此，已经证明了，当查询的索引含有唯一属性时，将next-key lock降级为record key</p>
<p>我们第二次创建的t1表的列b是主键，而主键必须是唯一的。</p>
<h3 id="实践2：-关闭GAP锁-RC" class="article-heading"><a href="#实践2：-关闭GAP锁-RC" class="headerlink" title="实践2： 关闭GAP锁_RC"></a>实践2： 关闭GAP锁_RC<a class="article-anchor" href="#实践2：-关闭GAP锁-RC" aria-hidden="true"></a></h3><p>有两种方式显式关闭gap锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock）</p>
<p>A. 将事务隔离级别设置为RC B. 将参数innodb_locks_unsafe_for_binlog设置为1</p>
<table>
<thead>
<tr>
<th align="left">T1 RR</th>
<th align="left">T2 RR</th>
</tr>
</thead>
<tbody><tr>
<td align="left">begin;</td>
<td align="left">begin;</td>
</tr>
<tr>
<td align="left">select * from db1.t1 where b=3 for update;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">insert into db1.t1 values (‘batman’,2)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">set session transaction isolation level READ COMMITTED;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">commit;</td>
<td align="left">commit;</td>
</tr>
</tbody></table>
<p>注意，将T1事务设置为RC后，需要将二进制日志的格式改为row格式，否则执行显式加锁时会报错</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">MariaDB [db1]&gt; insert into t1 values ('batman',2);</span><br><span class="line">ERROR 1665 (HY000): Cannot execute statement: impossible to write to binary log since BINLOG_FORMAT = STATEMENT and at least one table uses a storage engine limited to row-based logging. InnoDB is limited to row-logging when transaction isolation level is READ COMMITTED or READ UNCOMMITTED.</span><br></pre></td></tr></tbody></table></figure>

<table>
<thead>
<tr>
<th align="left">T1 RC</th>
<th align="left">T2 RR</th>
</tr>
</thead>
<tbody><tr>
<td align="left">begin;</td>
<td align="left">begin;</td>
</tr>
<tr>
<td align="left">set session transaction isolation level READ COMMITTED;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">select * from db1.t1 where b=3 for update;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">insert into db1.t1 values (‘batman’,2)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">insert into db1.t1 values (‘batman’,4)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">commit;</td>
<td align="left">commit;</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">T1事务</span></span><br><span class="line">MariaDB [db1]&gt; set session transaction isolation level READ COMMITTED;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [db1]&gt; select @@tx_isolation;</span><br><span class="line">+----------------+</span><br><span class="line">| @@tx_isolation |</span><br><span class="line">+----------------+</span><br><span class="line">| READ-COMMITTED |</span><br><span class="line">+----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [db1]&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.09 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [db1]&gt; select * from t1 where b=3 for update;</span><br><span class="line">+----------+------+</span><br><span class="line">| a        | b    |</span><br><span class="line">+----------+------+</span><br><span class="line">| superman |    3 |</span><br><span class="line">+----------+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">T2事务</span></span><br><span class="line">MariaDB [db1]&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.16 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [db1]&gt; select @@tx_isolation;</span><br><span class="line">+----------------+</span><br><span class="line">| @@tx_isolation |</span><br><span class="line">+----------------+</span><br><span class="line">| READ-COMMITTED |</span><br><span class="line">+----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [db1]&gt; insert into db1.t1 values ('batman',2);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [db1]&gt; commit;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [db1]&gt; set session transaction isolation level REPEATABLE READ;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [db1]&gt; select @@tx_isolation;</span><br><span class="line">+-----------------+</span><br><span class="line">| @@tx_isolation  |</span><br><span class="line">+-----------------+</span><br><span class="line">| REPEATABLE-READ |</span><br><span class="line">+-----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [db1]&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [db1]&gt; insert into db1.t1 values ('batman',4);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [db1]&gt; commit;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">T1事务</span></span><br><span class="line">MariaDB [db1]&gt; commit;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></tbody></table></figure>

<p>我在做测试的时候，T1事务隔离界别为RC，T2事务的隔离界别分别用RC和RR做了测试，都是可以的</p>
<h3 id="实践3：-关闭GAP锁-innodb-locks-unsafe-for-binlog" class="article-heading"><a href="#实践3：-关闭GAP锁-innodb-locks-unsafe-for-binlog" class="headerlink" title="实践3： 关闭GAP锁_innodb_locks_unsafe_for_binlog"></a>实践3： 关闭GAP锁_innodb_locks_unsafe_for_binlog<a class="article-anchor" href="#实践3：-关闭GAP锁-innodb-locks-unsafe-for-binlog" aria-hidden="true"></a></h3><p>查看当前innodb_locks_unsafe_for_binlog参数的值</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">MariaDB [(none)]&gt; select @@innodb_locks_unsafe_for_binlog;</span><br><span class="line">+----------------------------------+</span><br><span class="line">| @@innodb_locks_unsafe_for_binlog |</span><br><span class="line">+----------------------------------+</span><br><span class="line">|                                0 |</span><br><span class="line">+----------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></tbody></table></figure>

<p>修改参数，并重新启动服务</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/my.cnf</span><br><span class="line">innodb_locks_unsafe_for_binlog=1</span><br><span class="line">[root@localhost ~]# systemctl restart mariadb</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# mysql -e "select @@innodb_locks_unsafe_for_binlog"</span><br><span class="line">+----------------------------------+</span><br><span class="line">| @@innodb_locks_unsafe_for_binlog |</span><br><span class="line">+----------------------------------+</span><br><span class="line">|                                1 |</span><br><span class="line">+----------------------------------+</span><br></pre></td></tr></tbody></table></figure>

<p>还是去创建db1.t1表，如果已有就先drop；有列a和b，分别为char(10)和int型，并且b为key，注意b列为索引列，但并不是主键，因此不是唯一的。</p>
<table>
<thead>
<tr>
<th align="left">T1 RR</th>
<th align="left">T2 RR</th>
</tr>
</thead>
<tbody><tr>
<td align="left">begin;</td>
<td align="left">begin;</td>
</tr>
<tr>
<td align="left">select * from db1.t1 where b=3 for update;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">insert into db1.t1 values (‘batman’,2)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">insert into db1.t1 values (‘batman’,4)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">commit;</td>
<td align="left">commit;</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">MariaDB [db1]&gt; create table db1.t1 (a char(10),b int,key (b));</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [db1]&gt; insert into db1.t1 values ('batman',1),('superman',3),('leo',5);</span><br><span class="line">Query OK, 3 rows affected (0.15 sec)</span><br><span class="line">Records: 3  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">MariaDB [db1]&gt; select * from db1.t1;</span><br><span class="line">+----------+------+</span><br><span class="line">| a        | b    |</span><br><span class="line">+----------+------+</span><br><span class="line">| batman   |    1 |</span><br><span class="line">| superman |    3 |</span><br><span class="line">| leo      |    5 |</span><br><span class="line">+----------+------+</span><br><span class="line">3 rows in set (0.02 sec)</span><br></pre></td></tr></tbody></table></figure>

<p>接下来开启两个事务T1和T2，T1中查看b=3的行，显式加排他锁；T1未提交事务时，T2事务开启并尝试插入新行a=’batman’,b=2和a=’batman’,b=4；</p>
<p>T1事务</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">MariaDB [(none)]&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; select * from db1.t1 where b=3 for update;</span><br><span class="line">+----------+------+</span><br><span class="line">| a        | b    |</span><br><span class="line">+----------+------+</span><br><span class="line">| superman |    3 |</span><br><span class="line">+----------+------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></tbody></table></figure>

<p>T2事务</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">MariaDB [(none)]&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; insert into db1.t1 values ('batman',4);</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; insert into db1.t1 values ('batman',2);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; commit;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></tbody></table></figure>

<p>T1事务</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">MariaDB [(none)]&gt; commit;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="实践4：next-key-locking是如何解决幻读问题的" class="article-heading"><a href="#实践4：next-key-locking是如何解决幻读问题的" class="headerlink" title="实践4：next-key locking是如何解决幻读问题的"></a>实践4：next-key locking是如何解决幻读问题的<a class="article-anchor" href="#实践4：next-key-locking是如何解决幻读问题的" aria-hidden="true"></a></h3><p><img src="pic/lock19.png" alt="lock19"></p>
<p>首先什么是幻读呢？</p>
<p>举个例子，两个男孩同时在追求一个女生的故事</p>
<p>A问：你有男朋友吗？女孩对他说没有。A追求女孩的事件还没有提交，就是继续追求哈。</p>
<p>就在A追求的同时，B也在追求，并且直接让女孩做他的女朋友，女孩答应了，B的追求事件结束。</p>
<p>A又问：你有男朋友吗？ 女孩对他说我已经有男朋友了！ 呜呜呜 ！刚才你还没有的，怎么现在就有了呢？</p>
<p>女孩说，你也没说过你追我的时候不让别人追我啊！… … A哭着走了。</p>
<p><strong>幻读 Phantom Problem 是指在同一事务下，连续执行两次相同的sql语句可能导致不同的结果，第二次的sql语句可能会返回之前不存在的行。</strong></p>
<p>在刚才我举的例子里，A虽然问了女孩有没有男朋友，但是没有告诉女孩，在他追求时，不可以接受别人的追求，所以悲催的结局。</p>
<p>那么A怎么才能在他追求事件结束前让女孩不答应别人的追求呢？</p>
<p>innodb中的RR隔离级别是通过next-key locking是如何解决幻读问题的，就是锁住一个范围。</p>
<p>那么如果你是A你怎么做呢？你肯定要跟女孩说，只要我开始追求你，问了你有没有男朋友，在我结束追求你之前，你不可以答应别人的追求！我要把你脑子里记录男朋友的区域全部锁起来，啊哈啊！</p>
<p>下面我们来做一个测试，分别在RR和RC隔离级别中来实现：</p>
<p>测试使用表db1.t1 (a int primary key) ,记录有1,3,5</p>
<table>
<thead>
<tr>
<th align="left">T1 RC</th>
<th align="left">T2 RR</th>
</tr>
</thead>
<tbody><tr>
<td align="left">begin;</td>
<td align="left">begin;</td>
</tr>
<tr>
<td align="left">set session transaction isolation level READ COMMITTED;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">select * from db1.t1 where a&gt;3 for update;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">查询结果为5</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">insert into db1.t1 values (4);</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">commit;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">select * from db1.t1 where a&gt;3;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">查询结果为4 5</td>
<td align="left"></td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">MariaDB [db1]&gt; create table t1 (a int primary key);</span><br><span class="line">Query OK, 0 rows affected (0.22 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [db1]&gt; insert into t1 values (1),(3),(5);</span><br><span class="line">Query OK, 3 rows affected (0.02 sec)</span><br><span class="line">Records: 3  Duplicates: 0  Warnings: 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">事务T1</span></span><br><span class="line">MariaDB [db1]&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [db1]&gt; set session transaction isolation level read co</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [db1]&gt; select * from db1.t1 where a&gt;3 for update;</span><br><span class="line">+---+</span><br><span class="line">| a |</span><br><span class="line">+---+</span><br><span class="line">| 5 |</span><br><span class="line">+---+</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">事务T2</span></span><br><span class="line">MariaDB [db1]&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [db1]&gt; insert into db1.t1 values (4);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [db1]&gt; commit;</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">事务T1</span></span><br><span class="line">MariaDB [db1]&gt; select * from db1.t1 where a&gt;3 for update;</span><br><span class="line">+---+</span><br><span class="line">| a |</span><br><span class="line">+---+</span><br><span class="line">| 4 |</span><br><span class="line">| 5 |</span><br><span class="line">+---+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></tbody></table></figure>

<p>将会话中的隔离界别改为RR，并删除a=4记录。</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">MariaDB [db1]&gt; set session transaction isolation level repeatable read;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [db1]&gt; delete from db1.t1 where a=4;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br></pre></td></tr></tbody></table></figure>

<table>
<thead>
<tr>
<th align="left">T1 RR</th>
<th align="left">T2 RR</th>
</tr>
</thead>
<tbody><tr>
<td align="left">begin;</td>
<td align="left">begin;</td>
</tr>
<tr>
<td align="left">select * from db1.t1 where a&gt;3 for update;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">查询结果为5</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">insert into db1.t1 values (4);</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">commit;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">select * from db1.t1 where a&gt;3;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">查询结果为5</td>
<td align="left"></td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">事务T1</span></span><br><span class="line">MariaDB [(none)]&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; select * from db1.t1 where a&gt;3 for update;</span><br><span class="line">+---+</span><br><span class="line">| a |</span><br><span class="line">+---+</span><br><span class="line">| 5 |</span><br><span class="line">+---+</span><br><span class="line">1 row in set (0.02 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">事务T2</span></span><br><span class="line">MariaDB [(none)]&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; insert into db1.t1 values (4);</span><br><span class="line">ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction</span><br><span class="line">MariaDB [(none)]&gt; commit;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">事务T1</span></span><br><span class="line">MariaDB [(none)]&gt; select * from db1.t1 where a&gt;3 for update;</span><br><span class="line">+---+</span><br><span class="line">| a |</span><br><span class="line">+---+</span><br><span class="line">| 5 |</span><br><span class="line">+---+</span><br><span class="line">1 row in set (0.02 sec)</span><br></pre></td></tr></tbody></table></figure>

<h1 id="MVCC的实现原理" class="article-heading"><a href="#MVCC的实现原理" class="headerlink" title="MVCC的实现原理"></a>MVCC的实现原理<a class="article-anchor" href="#MVCC的实现原理" aria-hidden="true"></a></h1><p>MVCC的目的就是多版本并发控制，在数据库中的实现，就是为了解决读写冲突，它的实现原理主要是依赖：</p>
<ul>
<li>记录中的 3个隐式字段</li>
<li>undo日志</li>
<li>Read View 来实现的。</li>
</ul>
<h2 id="概念" class="article-heading"><a href="#概念" class="headerlink" title="概念"></a>概念<a class="article-anchor" href="#概念" aria-hidden="true"></a></h2><h3 id="隐式字段" class="article-heading"><a href="#隐式字段" class="headerlink" title="隐式字段"></a>隐式字段<a class="article-anchor" href="#隐式字段" aria-hidden="true"></a></h3><p>每行记录除了我们自定义的字段外，还有数据库隐式定义的 <code>DB_TRX_ID</code>,<code>DB_ROLL_PTR</code>,<code>DB_ROW_ID</code> 等字段</p>
<table>
<thead>
<tr>
<th align="left">字段</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">DB_TRX_ID</td>
<td align="left">6byte，最近修改(修改/插入)事务ID：记录创建这条记录/最后一次修改该记录的事务ID</td>
</tr>
<tr>
<td align="left">DB_ROLL_PTR</td>
<td align="left">7byte，回滚指针，指向这条记录的上一个版本（存储于rollback segment里）</td>
</tr>
<tr>
<td align="left">DB_ROW_ID</td>
<td align="left">6byte，隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引</td>
</tr>
</tbody></table>
<p>实际还有一个删除flag隐藏字段, 既记录被更新或删除并不代表真的删除，而是删除flag变了。</p>
<p>例如 users 表 假设没有指定主键。</p>
<table>
<thead>
<tr>
<th align="left">DB_ROW_ID</th>
<th align="left">用户名</th>
<th align="left">年龄</th>
<th align="left">DB_TRX_ID</th>
<th align="left">DB_ROLL_PTR</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">amy</td>
<td align="left">5</td>
<td align="left">1</td>
<td align="left">ox1234567</td>
</tr>
</tbody></table>
<p>如上图， <code>DB_ROW_ID</code> 是数据库默认为该行记录生成的唯一隐式主键， <code>DB_TRX_ID</code> 是当前操作该记录的事务 <code>ID</code>,而 <code>DB_ROLL_PTR</code> 是一个回滚指针，用于配合 <code>undo</code> 日志，指向上一个旧版本。</p>
<h3 id="undo日志" class="article-heading"><a href="#undo日志" class="headerlink" title="undo日志"></a>undo日志<a class="article-anchor" href="#undo日志" aria-hidden="true"></a></h3><p>undo log主要分为两种：</p>
<ul>
<li>insert undo log: 代表事务在insert新记录时产生的undo log, 只在事务回滚时需要，并且在事务提交后可以被立即丢弃</li>
<li>update undo log: 事务在进行update或delete时产生的undo log; 不仅在事务回滚时需要，在快照读时也需要；所以不能随便删除，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被purge线程统一清除</li>
</ul>
<blockquote>
<p>purge 从前面的分析可以看出，为了实现InnoDB的MVCC机制，更新或者删除操作都只是设置一下老记录的deleted_bit，并不真正将过时的记录删除。 为了节省磁盘空间，InnoDB有专门的purge线程来清理deleted_bit为true的记录。为了不影响MVCC的正常工作，purge线程自己也维护了一个read view（这个read view相当于系统中最老活跃事务的read view）;如果某个记录的deleted_bit为true，并且DB_TRX_ID相对于purge线程的read view可见，那么这条记录一定是可以被安全清除的。</p>
</blockquote>
<h3 id="Read-View" class="article-heading"><a href="#Read-View" class="headerlink" title="Read View"></a>Read View<a class="article-anchor" href="#Read-View" aria-hidden="true"></a></h3><p>什么是Read View，说白了Read View就是事务进行快照读操作的时候生产的读视图(Read View)，在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的ID(当每个事务开启时，都会被分配一个ID, 这个ID是递增的，所以最新的事务，ID值越大)</p>
<p>所以我们知道 Read View主要是用来做可见性判断的, 即当我们某个事务执行快照读的时候，对该记录创建一个Read View读视图，把它比作条件用来判断当前事务能够看到哪个版本的数据，既可能是当前最新的数据，也有可能是该行记录的undo log里面的某个版本的数据。</p>
<p>Read View遵循一个可见性算法，主要是将要被修改的数据的最新记录中的DB_TRX_ID（即当前事务ID）取出来，与系统当前其他活跃事务的ID去对比（由Read View维护），如果DB_TRX_ID跟Read View的属性做了某些比较，不符合可见性，那就通过DB_ROLL_PTR回滚指针去取出Undo Log中的DB_TRX_ID再比较，即遍历链表的DB_TRX_ID（从链首到链尾，即从最近的一次修改查起），直到找到满足特定条件的DB_TRX_ID, 那么这个DB_TRX_ID所在的旧记录就是当前事务能看见的最新老版本。</p>
<h2 id="执行流程" class="article-heading"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程<a class="article-anchor" href="#执行流程" aria-hidden="true"></a></h2><p>对MVCC有帮助的实质是<code>update undo log</code> ，<code>undo log</code>实际上就是存在<code>rollback segment</code>中旧记录链，它的执行流程如下：</p>
<h3 id="Insert-流程" class="article-heading"><a href="#Insert-流程" class="headerlink" title="Insert 流程"></a>Insert 流程<a class="article-anchor" href="#Insert-流程" aria-hidden="true"></a></h3><p>比如一个有个事务插入 <code>users</code> 表插入了一条新记录，记录如下，name为 <code>Amy</code>, <code>age</code> 为 <code>5</code> 岁，隐式主键是 <code>1</code>，事务ID和回滚指针，我们假设为NULL</p>
<p>行记录</p>
<table>
<thead>
<tr>
<th align="left">DB_ROW_ID</th>
<th align="left">用户名</th>
<th align="left">年龄</th>
<th align="left">DB_TRX_ID</th>
<th align="left">DB_ROLL_PTR</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">Sage</td>
<td align="left">5</td>
<td align="left">NULL</td>
<td align="left">NULL</td>
</tr>
</tbody></table>
<h3 id="Update-流程" class="article-heading"><a href="#Update-流程" class="headerlink" title="Update 流程"></a>Update 流程<a class="article-anchor" href="#Update-流程" aria-hidden="true"></a></h3><p>行记录</p>
<table>
<thead>
<tr>
<th align="left">DB_ROW_ID</th>
<th align="left">用户名</th>
<th align="left">年龄</th>
<th align="left">DB_TRX_ID</th>
<th align="left">DB_ROLL_PTR</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">Sage</td>
<td align="left">5</td>
<td align="left">1</td>
<td align="left">ox1234567</td>
</tr>
</tbody></table>
<p>Undo Log</p>
<table>
<thead>
<tr>
<th align="left">DB_ROW_ID</th>
<th align="left">用户名</th>
<th align="left">年龄</th>
<th align="left">DB_TRX_ID</th>
<th align="left">DB_ROLL_PTR</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">Amy</td>
<td align="left">5</td>
<td align="left">NULL</td>
<td align="left">NULL</td>
</tr>
</tbody></table>
<p>现在来了一个 <code>事务1</code> 对该记录的 <code>name</code> 做出了修改，改为 <code>Sage</code>。</p>
<ul>
<li>第一步: <code>事务1</code> 修改行记录时，数据库会先对该行加排他锁 <code>X</code>；</li>
<li>第二步: 将该行数据拷贝到 <code>undo log</code>中，作为旧记录，既在 <code>undo log</code> 中有当前行的拷贝副本；</li>
<li>第三步: 拷贝完毕后，修改数据块中的行记录值，将 <code>name</code> 改为 <code>Sage</code>，并且修改隐藏字段的事务ID <code>DB_TRX_ID</code>为当前事务ID <code>1</code>, 回滚指针指<code>DB_ROLL_PTR</code> 修改为向拷贝到<code>undo log</code>的副本记录，表示我的上一个版本就是它；</li>
<li>第四步：<code>事务1</code> 提交后，释放行锁。</li>
</ul>
<h3 id="再次-Update" class="article-heading"><a href="#再次-Update" class="headerlink" title="再次 Update"></a>再次 Update<a class="article-anchor" href="#再次-Update" aria-hidden="true"></a></h3><p>又来了个<code>事务2</code>修改<code>users</code>表的同一个记录，将 <code>age</code> 修改为<code>300</code>岁</p>
<p>行记录</p>
<table>
<thead>
<tr>
<th align="left">DB_ROW_ID</th>
<th align="left">用户名</th>
<th align="left">年龄</th>
<th align="left">DB_TRX_ID</th>
<th align="left">DB_ROLL_PTR</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">Sage</td>
<td align="left">300</td>
<td align="left">2</td>
<td align="left">ox1234568</td>
</tr>
</tbody></table>
<p>Undo Log</p>
<table>
<thead>
<tr>
<th align="left">DB_ROW_ID</th>
<th align="left">用户名</th>
<th align="left">年龄</th>
<th align="left">DB_TRX_ID</th>
<th align="left">DB_ROLL_PTR</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">Sage</td>
<td align="left">5</td>
<td align="left">1</td>
<td align="left">ox1234567</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">DB_ROW_ID</th>
<th align="left">用户名</th>
<th align="left">年龄</th>
<th align="left">DB_TRX_ID</th>
<th align="left">DB_ROLL_PTR</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">Amy</td>
<td align="left">5</td>
<td align="left">NULL</td>
<td align="left">NULL</td>
</tr>
</tbody></table>
<ul>
<li>第一步: 事务2修改该行数据时，数据库也先为该行加锁；</li>
<li>第二步: 然后把该行数据拷贝到 <code>undo log</code>中，作为旧记录，发现该行记录已经有<code>undo log</code>了，那么最新的旧数据作为链表的表头，插在该行记录的 <code>undo log</code> 最前面；</li>
<li>第三步: 修改该行 <code>age</code>为<code>300</code>岁，并且修改隐藏字段的事务ID为<code>2</code>，回滚指针指向刚刚拷贝到undo log的副本记录；</li>
<li>第四步: 事务提交，释放锁。</li>
</ul>
<p>从上面，我们就可以看出，不同事务或者相同事务的对同一记录的修改，会导致该记录的undo log成为一条记录版本线性表，既链表，undo log的链首就是最新的旧记录，链尾就是最早的旧记录（当然就像之前说的该undo log的节点可能是会purge线程清除掉，向图中的第一条insert undo log，其实在事务提交之后可能就被删除丢失了，不过这里为了演示，所以还放在这里）。</p>
</body></html>
              </div>
              <footer class="article-footer">
                <time class="article-footer-updated" datetime="2025-10-22T08:48:27.534Z" itemprop="dateModified">Last updated: 2025-10-22</time>
                <a href="/database/mysql/index.html" class="article-footer-next" title="概览"><span>Next</span><i class="fa fa-chevron-right"></i></a>
              </footer>
              
            </div>
          </div>
          <aside id="article-toc" role="navigation">
            <div id="article-toc-inner">
              <div id="carbonads" class="carbonads" style="text-align:center;font-family:'Noto Sans SC',sans-serif;">
  <span class="carbon-wrap">
    <a href="https://github.com/booboowei"
       class="carbon-img"
       target="_blank"
       rel="noopener sponsored">
      <img
        src="https://avatars2.githubusercontent.com/u/21328020?s=460&u=88cf6127c32932188f936d05636b7b0d36783ee1&v=4"
        alt="ads via Carbon"
        border="0"
        style="width:80px;height:80px;border-radius:50%;max-width:130px;"
      />
    </a>
    <a href="/about/"
       class="carbon-text"
       target="_blank"
       rel="noopener sponsored"
       style="display:block;margin-top:4px;">
      欢迎光临
    </a>
  </span>

  <!-- 日期显示 -->
  <div id="today-date" style="margin-top:12px;background:#f5f5f5;border-radius:12px;padding:10px 0;">
    <div id="weekday" style="font-size:14px;color:#555;"></div>
    <div id="day" style="font-size:36px;font-weight:bold;color:#000;"></div>
    <div id="ym" style="font-size:14px;color:#555;"></div>
    <div id="lunar" style="font-size:13px;color:#888;margin-top:4px;"></div>
  </div>

<script>
(function(){
  const now = new Date();
  const weekdays = ["星期日","星期一","星期二","星期三","星期四","星期五","星期六"];
  const year = now.getFullYear();
  const month = now.getMonth() + 1;
  const day = now.getDate();

  function toChineseNumber(num) {
    const map = {0:'〇',1:'一',2:'二',3:'三',4:'四',5:'五',6:'六',7:'七',8:'八',9:'九'};
    return String(num).split('').map(n=>map[n]).join('');
  }

  // 优先使用 Intl (现代浏览器支持农历/中国传统历)
  function getLunarByIntl(date) {
    try {
      // 获取农历的月（长格式，如 "九月" 或 "闰八月"），和日（数字）
      const monthFormatter = new Intl.DateTimeFormat('zh-CN-u-ca-chinese', { month: 'long' });
      const dayFormatter = new Intl.DateTimeFormat('zh-CN-u-ca-chinese', { day: 'numeric' });
      const lunarMonthText = monthFormatter.format(date); // 例如 "九月" 或 "闰八月"
      const lunarDayText = dayFormatter.format(date);     // 例如 "三十" 或 "初一"
      // 有的浏览器返回的 month 会包含 "闰" 字样，也可能返回汉字月份，需要适配
      return `农历${lunarMonthText}${lunarDayText}`;
    } catch (e) {
      return null; // 表示不支持 Intl 农历
    }
  }

  // 回退：简易本地农历算法（仅作兼容，适用于1900-2049范围）
  const lunarInfo = [0x04bd8,0x04ae0,0x0a570,0x054d5,0x0d260,0x0d950,0x16554,0x056a0,0x09ad0,0x055d2,
                     0x04ae0,0x0a5b6,0x0a4d0,0x0d250,0x1d255,0x0b540,0x0d6a0,0x0ada2,0x095b0,0x14977,
                     0x04970,0x0a4b0,0x0b4b5,0x06a50,0x06d40,0x1ab54,0x02b60,0x09570,0x052f2,0x04970,
                     0x06566,0x0d4a0,0x0ea50,0x06e95,0x05ad0,0x02b60,0x186e3,0x092e0,0x1c8d7,0x0c950,
                     0x0d4a0,0x1d8a6,0x0b550,0x056a0,0x1a5b4,0x025d0,0x092d0,0x0d2b2,0x0a950,0x0b557,
                     0x06ca0,0x0b550,0x15355,0x04da0,0x0a5b0,0x14573,0x052b0,0x0a9a8,0x0e950,0x06aa0,
                     0x0aea6,0x0ab50,0x04b60,0x0aae4,0x0a570,0x05260,0x0f263,0x0d950,0x05b57,0x056a0,
                     0x096d0,0x04dd5,0x04ad0,0x0a4d0,0x0d4d4,0x0d250,0x0d558,0x0b540,0x0b5a0,0x195a6,
                     0x095b0,0x049b0,0x0a974,0x0a4b0,0x0b27a,0x06a50,0x06d40,0x0af46,0x0ab60,0x09570,
                     0x04af5,0x04970,0x064b0,0x074a3,0x0ea50,0x06b58,0x05ac0,0x0ab60,0x096d5,0x092e0];

  function lYearDays(y){let i,sum=348;for(i=0x8000;i>0x8;i>>=1)sum+=(lunarInfo[y-1900]&i)?1:0;return sum+leapDays(y);}
  function leapDays(y){if(leapMonth(y))return(lunarInfo[y-1900]&0x10000)?30:29;else return 0;}
  function leapMonth(y){return lunarInfo[y-1900]&0xf;}
  function monthDays(y,m){return(lunarInfo[y-1900]&(0x10000>>m))?30:29;}

  function LunarFallback(objDate){
    let i, leap=0, temp=0;
    const baseDate = new Date(1900,0,31);
    let offset = Math.floor((objDate - baseDate) / 86400000);
    let year = 1900;
    // 年循环
    for (i = 1900; i < 2050 && offset > 0; i++) {
      temp = lYearDays(i);
      offset -= temp;
      year = i;
    }
    if (offset < 0) { offset += temp; year--; }
    leap = leapMonth(year);
    let isLeap = false;
    let month = 1;
    // 月循环
    for (i = 1; i <= 12 && offset > 0; i++) {
      if (leap > 0 && i === (leap + 1) && !isLeap) {
        // 进入闰月
        temp = leapDays(year);
        isLeap = true;
        i--; // stay on same month number but mark leap
      } else {
        temp = monthDays(year, i);
      }
      offset -= temp;
      if (isLeap && i === leap) { isLeap = false; }
      if (!isLeap) month++; // 非闰月时才推进月份计数
    }
    if (offset === 0 && leap > 0 && month === leap + 1) {
      // 特殊：当正好落在闰月第一天
      // month 保持，isLeap = true
    }
    if (offset < 0) { offset += temp; month--; }
    const day = offset + 1;
    // 修正 month 边界
    if (month <= 0) month = 1;
    return { year, month, day, isLeap: !!isLeap };
  }

  function getLunarDateStringFallback(y,m,d){
    const cDay=["","初一","初二","初三","初四","初五","初六","初七","初八","初九","初十",
                "十一","十二","十三","十四","十五","十六","十七","十八","十九","二十",
                "廿一","廿二","廿三","廿四","廿五","廿六","廿七","廿八","廿九","三十"];
    const cMon=["","正月","二月","三月","四月","五月","六月","七月","八月","九月","十月","冬月","腊月"];
    const lunar = LunarFallback(new Date(y, m-1, d));
    return `农历${lunar.isLeap ? '闰' : ''}${cMon[lunar.month]}${cDay[lunar.day]}`;
  }

  // 先尝试 Intl 方法
  let lunarText = getLunarByIntl(now);
  if (!lunarText) {
    // 回退本地算法
    lunarText = getLunarDateStringFallback(year, month, day);
  }

  // 输出到页面（公历 + 农历）
  document.getElementById("weekday").textContent = weekdays[now.getDay()];
  document.getElementById("day").textContent = day;
  document.getElementById("ym").textContent = `${toChineseNumber(year)}年${toChineseNumber(month)}月`;
  document.getElementById("lunar").textContent = lunarText;
})();
</script>


              <strong class="sidebar-title">Contents</strong>
              <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#MySQL-%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84"><span class="toc-text">MySQL 逻辑架构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MySQL-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-text">MySQL 存储引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%A6%82%E8%BF%B0"><span class="toc-text">存储引擎概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E5%90%8D%E7%9A%84%E4%B8%A4%E5%A4%A7%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-text">知名的两大存储引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#master-thread"><span class="toc-text">master thread:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#loop%E4%B8%BB%E5%BE%AA%E7%8E%AF%E6%AF%8F%E7%A7%92%E4%B8%80%E6%AC%A1%E7%9A%84%E6%93%8D%E4%BD%9C%EF%BC%9A"><span class="toc-text">loop主循环每秒一次的操作：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#loop%E4%B8%BB%E5%BE%AA%E7%8E%AF%E6%AF%8F%E5%8D%81%E7%A7%92%E4%B8%80%E6%AC%A1%E7%9A%84%E6%93%8D%E4%BD%9C%EF%BC%9A"><span class="toc-text">loop主循环每十秒一次的操作：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#backgroud-loop%EF%BC%8C%E8%8B%A5%E5%BD%93%E5%89%8D%E6%B2%A1%E6%9C%89%E7%94%A8%E6%88%B7%E6%B4%BB%E5%8A%A8-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%A9%BA%E9%97%B2%E6%97%B6-%E6%88%96%E8%80%85%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%97%AD%E6%97%B6%EF%BC%8C%E5%B0%B1%E4%BC%9A%E5%88%87%E6%8D%A2%E5%88%B0%E8%BF%99%E4%B8%AA%E5%BE%AA%E7%8E%AF%EF%BC%9A"><span class="toc-text">backgroud loop，若当前没有用户活动(数据库空闲时)或者数据库关闭时，就会切换到这个循环：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#flush-loop-%E5%88%B7%E6%96%B0%E5%BE%AA%E7%8E%AF%EF%BC%8C%E5%8C%85%E6%8B%AC%EF%BC%9A"><span class="toc-text">flush loop 刷新循环，包括：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#suspend-loop%E6%9A%82%E5%81%9C%E5%BE%AA%E7%8E%AF%EF%BC%8C%E5%8C%85%E6%8B%AC%EF%BC%9A"><span class="toc-text">suspend_loop暂停循环，包括：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E7%BC%93%E5%86%B2%EF%BC%9A"><span class="toc-text">插入缓冲：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E6%AC%A1%E5%86%99%EF%BC%9A"><span class="toc-text">两次写：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#INNODB-%E7%9A%84%E8%A1%A8"><span class="toc-text">INNODB 的表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-text">事务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="toc-text">并发控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E6%9C%BA%E5%88%B6"><span class="toc-text">锁机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6-MVCC"><span class="toc-text">多版本并发控制 MVCC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-text">事务的隔离级别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#INNODB%E9%94%81"><span class="toc-text">INNODB锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AEINNODB%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-text">设置INNODB事务隔离级别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E8%B7%B51%EF%BC%9A%E6%9F%A5%E7%9C%8Binnodb%E9%BB%98%E8%AE%A4%E7%9A%84%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-text">实践1：查看innodb默认的事务隔离级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E8%B7%B52%EF%BC%9A%E6%94%B9%E5%8F%98%E5%8D%95%E4%B8%AA%E4%BC%9A%E8%AF%9D%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-text">实践2：改变单个会话的隔离级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E8%B7%B53%EF%BC%9A%E6%94%B9%E5%8F%98%E5%8D%95%E4%B8%AA%E5%AE%9E%E4%BE%8B%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-text">实践3：改变单个实例的隔离级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E8%B7%B54%EF%BC%9A%E6%94%B9%E5%8F%98%E6%89%80%E6%9C%89%E5%AE%9E%E4%BE%8B%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-text">实践4：改变所有实例的隔离级别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BA%E5%88%86INNODB%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-text">区分INNODB事务隔离级别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB-%E4%B8%AD%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E8%AF%A6%E7%BB%86%E6%8F%8F%E8%BF%B0"><span class="toc-text">InnoDB 中的隔离级详细描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E8%B7%B51%EF%BC%9ASERIALIZABLE%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%9F%A5%E8%AF%A2%E8%87%AA%E5%8A%A8%E5%8A%A0%E5%85%B1%E4%BA%AB%E9%94%81"><span class="toc-text">实践1：SERIALIZABLE隔离级别查询自动加共享锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E8%B7%B52%EF%BC%9ARU%E3%80%81RC%E3%80%81RR%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-text">实践2：RU、RC、RR隔离级别的对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E8%87%B4%E6%80%A7%E9%94%81%E5%AE%9A%E8%AF%BB"><span class="toc-text">实现一致性锁定读</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E8%B7%B51%EF%BC%9A%E8%AE%BE%E7%BD%AEinnodb%E7%94%B3%E8%AF%B7%E9%94%81%E7%AD%89%E5%BE%85%E8%B6%85%E6%97%B6%E6%97%B6%E9%97%B4"><span class="toc-text">实践1：设置innodb申请锁等待超时时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E8%B7%B52%EF%BC%9A%E8%AE%BE%E7%BD%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%94%81%E5%AE%9A%E8%AF%BB%EF%BC%8C%E5%8A%A0%E5%85%B1%E4%BA%AB%E9%94%81%E6%B5%8B%E8%AF%95"><span class="toc-text">实践2：设置一致性锁定读，加共享锁测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E8%B7%B53%EF%BC%9A%E8%AE%BE%E7%BD%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%94%81%E5%AE%9A%E8%AF%BB%EF%BC%8C%E5%8A%A0%E6%8E%92%E4%BB%96%E9%94%81%E6%B5%8B%E8%AF%95"><span class="toc-text">实践3：设置一致性锁定读，加排他锁测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A4%E8%AF%86%E9%94%81%E7%9A%84%E7%AE%97%E6%B3%95"><span class="toc-text">认识锁的算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-text">知识点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E8%B7%B51%EF%BC%9A-%E9%AA%8C%E8%AF%81next-key-lock%E9%99%8D%E7%BA%A7%E4%B8%BArecord-key"><span class="toc-text">实践1： 验证next-key lock降级为record key</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E8%B7%B52%EF%BC%9A-%E5%85%B3%E9%97%ADGAP%E9%94%81-RC"><span class="toc-text">实践2： 关闭GAP锁_RC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E8%B7%B53%EF%BC%9A-%E5%85%B3%E9%97%ADGAP%E9%94%81-innodb-locks-unsafe-for-binlog"><span class="toc-text">实践3： 关闭GAP锁_innodb_locks_unsafe_for_binlog</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E8%B7%B54%EF%BC%9Anext-key-locking%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB%E9%97%AE%E9%A2%98%E7%9A%84"><span class="toc-text">实践4：next-key locking是如何解决幻读问题的</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MVCC%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">MVCC的实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-text">概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E5%AD%97%E6%AE%B5"><span class="toc-text">隐式字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undo%E6%97%A5%E5%BF%97"><span class="toc-text">undo日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Read-View"><span class="toc-text">Read View</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-text">执行流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Insert-%E6%B5%81%E7%A8%8B"><span class="toc-text">Insert 流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Update-%E6%B5%81%E7%A8%8B"><span class="toc-text">Update 流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%8D%E6%AC%A1-Update"><span class="toc-text">再次 Update</span></a></li></ol></li></ol></li></ol>
              <a href="#" id="article-toc-top">Back to Top</a>
            </div>
          </aside>
        </div>
      </article>
      <aside id="sidebar" role="navigation">
  <div class="inner">
    <strong class="sidebar-title">MySQL</strong><a href="/database/mysql/index.html" class="sidebar-link">概览</a><a href="/database/mysql/booboo_mysql/index.html" class="sidebar-link">MySQL 基础</a><a href="/database/mysql/dba_mysql/index.html" class="sidebar-link">MySQL 运维实践</a><a href="/database/mysql/rds_mysql/index.html" class="sidebar-link">RDS 性能调优</a><a href="/database/mysql/security/index.html" class="sidebar-link">安全篇</a><a href="/database/mysql/awesome-tools/index.html" class="sidebar-link">工具篇</a><strong class="sidebar-title">Oracle</strong><a href="/database/oracle/index.html" class="sidebar-link">概览</a><a href="/database/oracle/ocp/index.html" class="sidebar-link">Oracle12C OCP</a><a href="/database/oracle/oracle-12c/index.html" class="sidebar-link">Oracle 12c 学习笔记</a><a href="/database/oracle/oracle-11g/index.html" class="sidebar-link">Oracle 11g 学习笔记</a><strong class="sidebar-title">NoSQL</strong><a href="/database/nosql/index.html" class="sidebar-link">概览</a><a href="/database/nosql/booboo_redis/index.html" class="sidebar-link">Redis 基础</a><a href="/database/nosql/dba_redis/index.html" class="sidebar-link">Redis 进阶</a><a href="/database/nosql/booboo_mongodb/index.html" class="sidebar-link">MongoDB 基础</a><a href="/database/nosql/hadoop/index.html" class="sidebar-link">Hadoop 基础</a><strong class="sidebar-title">TiDB</strong><a href="/database/tidb/index.html" class="sidebar-link">概览</a><a href="/database/tidb/00_tidb入门指南.html" class="sidebar-link">TiDB 入门指南</a><a href="/database/tidb/01_raft协议理解.html" class="sidebar-link">Raft协议理解</a><a href="/database/tidb/tidb_courses/index.html" class="sidebar-link">TiDB 21天课程</a>
  </div>
</aside>
    </div>
  </div>
</div>

    <footer id="footer" class="wrapper">
  <div class="inner">
    <div id="footer-copyright">
      &copy; 2025 <a href="https://github.com/BoobooWei" target="_blank">魏亚萍</a><br>
      Documentation licensed under <a href="http://creativecommons.org/licenses/by/4.0/" target="_blank">CC BY 4.0</a>.<br>
      备案号：沪ICP备2020026043号
    </div>
    <div id="footer-links">
      <a href="https://www.youtube.com/@amyreading2023" class="footer-link" target="_blank">
        <img src="https://upload.wikimedia.org/wikipedia/commons/b/b8/YouTube_Logo_2017.svg" 
            alt="YouTube"
            style="height:24px; margin-bottom:-6px;">
      </a>
      <a href="https://github.com/BoobooWei" class="footer-link" target="_blank"><i class="fa fa-github-alt"></i></a>
    </div>
  </div>
</footer>

  </div>
  <div id="mobile-nav-dimmer"></div>
  <nav id="mobile-nav">
  <div id="mobile-nav-inner">
    <ul id="mobile-nav-list">
      <a href="../../../docs/" class="mobile-nav-link">Hexo</a><a href="../../../news/" class="mobile-nav-link">News</a><a href="../../../api/" class="mobile-nav-link">MySQL8.0</a><a href="../../../database/" class="mobile-nav-link">Database</a><a href="../../../linux/" class="mobile-nav-link">Linux</a><a href="../../../cloud/" class="mobile-nav-link">Cloud</a><a href="../../../singapore/" class="mobile-nav-link">Singapore</a><a href="../../../amy/" class="mobile-nav-link">AMY</a><a href="../../../about/" class="mobile-nav-link">About</a>
      <li class="mobile-nav-item">
        <a href="https://github.com/BoobooWei" class="mobile-nav-link" rel="external" target="_blank">GitHub</a>
      </li>
    </ul>
    
      <strong class="mobile-nav-title">MySQL</strong><a href="/database/mysql/index.html" class="mobile-nav-link">概览</a><a href="/database/mysql/booboo_mysql/index.html" class="mobile-nav-link">MySQL 基础</a><a href="/database/mysql/dba_mysql/index.html" class="mobile-nav-link">MySQL 运维实践</a><a href="/database/mysql/rds_mysql/index.html" class="mobile-nav-link">RDS 性能调优</a><a href="/database/mysql/security/index.html" class="mobile-nav-link">安全篇</a><a href="/database/mysql/awesome-tools/index.html" class="mobile-nav-link">工具篇</a><strong class="mobile-nav-title">Oracle</strong><a href="/database/oracle/index.html" class="mobile-nav-link">概览</a><a href="/database/oracle/ocp/index.html" class="mobile-nav-link">Oracle12C OCP</a><a href="/database/oracle/oracle-12c/index.html" class="mobile-nav-link">Oracle 12c 学习笔记</a><a href="/database/oracle/oracle-11g/index.html" class="mobile-nav-link">Oracle 11g 学习笔记</a><strong class="mobile-nav-title">NoSQL</strong><a href="/database/nosql/index.html" class="mobile-nav-link">概览</a><a href="/database/nosql/booboo_redis/index.html" class="mobile-nav-link">Redis 基础</a><a href="/database/nosql/dba_redis/index.html" class="mobile-nav-link">Redis 进阶</a><a href="/database/nosql/booboo_mongodb/index.html" class="mobile-nav-link">MongoDB 基础</a><a href="/database/nosql/hadoop/index.html" class="mobile-nav-link">Hadoop 基础</a><strong class="mobile-nav-title">TiDB</strong><a href="/database/tidb/index.html" class="mobile-nav-link">概览</a><a href="/database/tidb/00_tidb入门指南.html" class="mobile-nav-link">TiDB 入门指南</a><a href="/database/tidb/01_raft协议理解.html" class="mobile-nav-link">Raft协议理解</a><a href="/database/tidb/tidb_courses/index.html" class="mobile-nav-link">TiDB 21天课程</a>
    
  </div>
  <div id="mobile-lang-select-wrap">
    <span id="mobile-lang-select-label"><i class="fa fa-globe"></i><span>English</span></span>
    <select id="mobile-lang-select" data-canonical="">
      
        <option value="en" selected>English</option>
      
    </select>
  </div>
</nav>
  <!-- Scripts -->
<!-- Cookie -->
<script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script>
<!-- build:js build/js/main.js -->

<script src="../../../js/lang_select.js"></script>


<script src="../../../js/mobile_nav.js"></script>

<!-- endbuild -->

<!-- Algolia -->
<!--   backup
<script src="https://cdn.jsdelivr.net/npm/@docsearch/js@3"></script>
<script type="text/javascript">
docsearch({
  appId: '',
  apiKey: '',
  indexName: '',
  insights: true,
  container: '#docsearch',
  debug: false,
  searchParameters: {
    facetFilters: ['lang:en']
  }
});
</script>
-->

<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script type="text/javascript">
document.getElementById('search-input-wrap').classList.add('on');
docsearch({
    apiKey: '',
    indexName: '',
    inputSelector: '#search-input'
});
</script>
</body>
</html>